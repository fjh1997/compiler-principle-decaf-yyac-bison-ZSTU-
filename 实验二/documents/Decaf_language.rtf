{\rtf1\ansi\ansicpg936\uc2 \deff0\deflang1033\deflangfe2052{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}{\f6\fmodern\fcharset0\fprq1{\*\panose 00000000000000000000}Courier;}{\f17\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}\'cb\'ce\'cc\'e5{\*\falt SimSun};}
{\f28\fnil\fcharset134\fprq2{\*\panose 02010600030101010101}@\'cb\'ce\'cc\'e5;}{\f29\froman\fcharset238\fprq2 Times New Roman CE;}{\f30\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f32\froman\fcharset161\fprq2 Times New Roman Greek;}
{\f33\froman\fcharset162\fprq2 Times New Roman Tur;}{\f34\froman\fcharset177\fprq2 Times New Roman (Hebrew);}{\f35\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f36\froman\fcharset186\fprq2 Times New Roman Baltic;}
{\f37\fswiss\fcharset238\fprq2 Arial CE;}{\f38\fswiss\fcharset204\fprq2 Arial Cyr;}{\f40\fswiss\fcharset161\fprq2 Arial Greek;}{\f41\fswiss\fcharset162\fprq2 Arial Tur;}{\f42\fswiss\fcharset177\fprq2 Arial (Hebrew);}
{\f43\fswiss\fcharset178\fprq2 Arial (Arabic);}{\f44\fswiss\fcharset186\fprq2 Arial Baltic;}{\f167\fnil\fcharset0\fprq2 SimSun Western{\*\falt SimSun};}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;
\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;
\red192\green192\blue192;}{\stylesheet{\qj \li0\ri0\nowidctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs21\lang1033\langfe2052\kerning2\loch\f0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 \snext0 Normal;}{\*\cs10 \additive 
Default Paragraph Font;}}{\info{\author Zhang}{\operator Zhang}{\creatim\yr2001\mo9\dy7\hr16\min42}{\revtim\yr2001\mo9\dy7\hr17\min20}{\version8}{\edmins37}{\nofpages9}{\nofwords3604}{\nofchars20547}{\*\company Soft Lab}{\nofcharsws25233}{\vern8249}}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\gutter0 \ftnbj\aenddoc\hyphcaps0\horzdoc\dghspace120\dgvspace120\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind1\viewscale100 \fet0\sectd \linex0\sectdefaultcl 
{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta \dbch .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang
{\pntxta \dbch )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}
{\pntxta \dbch )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb \dbch (}{\pntxta \dbch )}}\pard\plain \ql \li0\ri0\nowidctlpar\faauto\rin0\lin0\itap0 
\fs21\lang1033\langfe2052\kerning2\loch\af0\hich\af0\dbch\af17\cgrid\langnp1033\langfenp2052 {\b\f1\fs36\kerning0 \hich\af1\dbch\af17\loch\f1 The Decaf language}{\b\f1\fs22\kerning0 \hich\af1\dbch\af17\loch\f1 1
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
In this course, we will write a compiler for a simple object-oriented programming language called Decaf. Decaf is a strongly-typed, object-oriented language with support for inheritance and encapsulation. By design, it has many similari
\hich\af0\dbch\af17\loch\f0 
ties with C/C++/Java, so you should find it fairly easy to pick up. Keep in mind it is not an exact match to any of those languages. The feature set has been trimmed down and simplified to keep the programming projects manageable. Even so, you'll still fi
\hich\af0\dbch\af17\loch\f0 n\hich\af0\dbch\af17\loch\f0 d the language expressive enough to build all sorts of nifty object-oriented programs.
\par \hich\af0\dbch\af17\loch\f0 This document is designed to give the specification for the language syntax and semantics, which you will need to refer to when implementing the course projects.
\par 
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Lexica\hich\af1\dbch\af17\loch\f1 l considerations
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 The following are keywords}{\i\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 . }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 They are all reserved.
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 void int double bool string class true false null this extends
\par \hich\af6\dbch\af17\loch\f6 for while if else return New NewArray Print ReadInteger ReadLine
\par 
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 An identifier is a sequence of letters, digits, and undersc\hich\af0\dbch\af17\loch\f0 ores, starting with a letter. Decaf is casesensitive,e.g., }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 if }{
\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is a keyword, but }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 IF }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is an identifier; }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 binky }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 and }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 Binky }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 are two distinct identifiers.
\par 
\par \hich\af0\dbch\af17\loch\f0 Whitespace (i.e. spaces, tabs, and newlines) serves to separate tokens, but is otherwise ignored.Keywords an\hich\af0\dbch\af17\loch\f0 
d identifiers must be separated by whitespace or a token that is neither a keyword noran identifier. }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ifintthis }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is a single identifier, not three keywords. }{
\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 if(23this }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 scans as four tokens.
\par 
\par \hich\af0\dbch\af17\loch\f0 An integer constant can either be specified in decimal (base 10) or \hich\af0\dbch\af17\loch\f0 hexadecimal (base 16). A decimal integer is a sequence of decimal digits (}{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 0-9)}{
\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 . A hexadecimal integer must begin with }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 0X }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 or }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 0x }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 (that is a zero, not the letter oh) and is followed by a sequence of hexadecimal digits.
\par \hich\af0\dbch\af17\loch\f0 Hexadecimal digits include the decimal d\hich\af0\dbch\af17\loch\f0 igits and the letters }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 a }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 through }{\f6\fs20\kerning0 
\hich\af6\dbch\af17\loch\f6 f }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (either upper or
\par \hich\af0\dbch\af17\loch\f0 lowercase). Examples of valid integers}{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 : 8, 012, 0x0, 0X12aE
\par 
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 A double constant is a sequence of digits, a period, followed by any sequence of digits, maybe none. Thus, }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 .12 }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
is not a valid double but both }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 0.\hich\af6\dbch\af17\loch\f6 12 }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 and }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 12}{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 . are valid. A double can also have an optional exponent, e.g., }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 12.2E+2 }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
For a double in this sort of scientific notation, the decimal point is required, the sign of the exponent is required, and the E can be lower or upper case. As above,.}{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 12E+2 }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 is\hich\af0\dbch\af17\loch\f0  invalid, but }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 12.E+2 }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is valid. Leading zeroes on the mantissa and exponent are allowed.
\par 
\par \hich\af0\dbch\af17\loch\f0 A string constant is a sequence of characters enclosed in double quotes. Strings can contain any character except a newline or double quote. A string cannot be split o\hich\af0\dbch\af17\loch\f0 ver several lines, e.g.,
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 "this is not a
\par \hich\af6\dbch\af17\loch\f6 valid string constant"
\par 
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Operators and punctuation characters used by the language includes:
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 + - * / % \\ < <= > >= = == != && || ! ; , . [ ] ( ) \{ \}
\par 
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 A single-line comment is started by }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 // }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 and extends to the end of th\hich\af0\dbch\af17\loch\f0 
e line. Multi-line comments start with }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 /* }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 and end with }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 */ }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
and can be nested. Any symbol is allowed in a comment except the sequence }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 */ }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 which ends the current comment or }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 /* 
}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 which starts a nested comment.
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 /* this is a comment and it can span multiple lines
\par \hich\af6\dbch\af17\loch\f6 a\hich\af6\dbch\af17\loch\f6 nd even /* nest /*inside */ one */ another */
\par }{\fs10\kerning0 \hich\af0\dbch\af17\loch\f0 1 }{\fs18\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf is a revision of the SOOP language developed by Maggie Johnson and Steve Freund.}{\fs20\kerning0 
\par }{\fs24\kerning0 
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Reference grammar
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 The reference grammar is given in a variant of extended BNF. The meta-notation used:
\par 
\par }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 x }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (in bold font)\hich\af0\dbch\af17\loch\f0  means that x is a terminal i.e., a token. Terminal names are also all
\par \hich\af0\dbch\af17\loch\f0 lowercase except for those few keywords that use capitals.
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 y }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (in plain text) means y is a nonterminal. All nonterminal names are capitalized.
\par }{\f3\fs20\kerning0 \loch\af3\dbch\af17\hich\f3 \'e1\'20}{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 x }{\f3\fs20\kerning0 \loch\af3\dbch\af17\hich\f3 \'f1\'20}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
means zero or one occurrence of x, i.e., x is optional
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 x* }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 means zero or more occurrences of x
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 x+}{\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 , }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 a comma-separated list of one or more x's
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 separates alternatives
\par }{\f3\fs20\kerning0 \loch\af3\dbch\af17\hich\f3 \'b6\'20}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 indicates epsilon, the absence of tokens
\par 
\par \hich\af0\dbch\af17\loch\f0 For readability, we represent operators b\hich\af0\dbch\af17\loch\f0 y the lexeme that denotes them, such as + or != as opposed to the token (T_NotEqual, etc.) returned by the scanner.
\par 
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Program ::= Decl*
\par \hich\af1\dbch\af17\loch\f1 Decl ::= VariableDecl | ClassDefn | FunctionDefn | FunctionDecl
\par \hich\af1\dbch\af17\loch\f1 VariableDecl ::= Variable }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ;
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Variable ::= Type }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 identifier
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Type ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 int }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 double }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 bool }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 string }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{
\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 void }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 class identifier }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | Type }{\b\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 [ ]
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 FunctionDecl ::= Type }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 identifier ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Formals }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ) ;
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Formals ::= Variable+, | }{\f3\fs20\kerning0 \loch\af3\dbch\af17\hich\f3 \'b6}{\f3\fs20\kerning0 
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 FunctionDefn ::= Type }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 identifier ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Formals }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ) }{
\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 StmtBlock
\par \hich\af1\dbch\af17\loch\f1 ClassDefn ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 class identifier }{\f3\fs24\kerning0 \loch\af3\dbch\af17\hich\f3 \'e1\'20}{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 extends identifier }{\f3\fs24\kerning0 
\loch\af3\dbch\af17\hich\f3 \'f1\'20}{\b\f1\fs20\kerning0 \{\hich\af1\dbch\af17\loch\f1  }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Field* }{\b\f1\fs20\kerning0 \}
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Field ::= VariableDecl | FunctionDecl | FunctionDefn
\par \hich\af1\dbch\af17\loch\f1 StmtBlock ::= }{\b\f1\fs20\kerning0 \{\hich\af1\dbch\af17\loch\f1  }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Stmt* }{\b\f1\fs20\kerning0 \}
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Stmt ::= VariableDecl | SimpleStmt }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ; }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | IfStmt | WhileStmt\hich\af1\dbch\af17\loch\f1  |
\par \hich\af1\dbch\af17\loch\f1 ForStmt | ReturnStmt }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ; }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | PrintStmt }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ; }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 | StmtBlock
\par \hich\af1\dbch\af17\loch\f1 SimpleStmt ::= LValue }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 = }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | Expr | }{\f3\fs20\kerning0 \loch\af3\dbch\af17\hich\f3 \'b6}{\f3\fs20\kerning0 
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 LValue ::= }{\f3\fs24\kerning0 \loch\af3\dbch\af17\hich\f3 \'e1\'20}{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 . }{\f3\fs24\kerning0 
\loch\af3\dbch\af17\hich\f3 \'f1\'20}{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 identifier }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 [ }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 
Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ]
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Call ::= }{\f3\fs24\kerning0 \loch\af3\dbch\af17\hich\f3 \'e1\'20}{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 . }{\f3\fs24\kerning0 
\loch\af3\dbch\af17\hich\f3 \'f1\'20}{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 identifier ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Actuals }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 )
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Actuals ::= Expr+, | }{\f3\fs20\kerning0 \loch\af3\dbch\af17\hich\f3 \'b6}{\f3\fs20\kerning0 
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ForStmt ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 for ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 SimpleStmt }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ; }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 BoolExpr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ; }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 SimpleS\hich\af1\dbch\af17\loch\f1 tmt }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ) }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 Stmt
\par \hich\af1\dbch\af17\loch\f1 WhileStmt ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 while ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 BoolExpr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ) }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 Stmt
\par \hich\af1\dbch\af17\loch\f1 IfStmt ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 if ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 BoolExpr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ) }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 
Stmt }{\f3\fs24\kerning0 \loch\af3\dbch\af17\hich\f3 \'e1\'20}{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 else }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Stmt }{\f3\fs24\kerning0 \loch\af3\dbch\af17\hich\f3 \'f1}{\f3\fs24\kerning0 
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ReturnStmt ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 return }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 return }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 Expr
\par \hich\af1\dbch\af17\loch\f1 PrintStmt ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Print ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr+, }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 )
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 BoolExpr ::= Expr
\par \hich\af1\dbch\af17\loch\f1 Expr ::= Constant | Lvalue | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 this }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | Call | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ( }{\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ) }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 |
\par \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 + }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 - }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 E
\hich\af1\dbch\af17\loch\f1 xpr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 * }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr |
\par \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 / }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 % }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | }{
\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 - }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr |
\par \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 < }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 <= }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 
Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 > }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr |
\par \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 >= }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 == }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 
Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 != }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr |
\par \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 && }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | Expr }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 || }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr | }
{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ! }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr |
\par }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ReadInteger ( ) }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 ReadLine ( ) }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 |
\par }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 New (identifier) }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 NewArray ( }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Expr }{\b\f1\fs20\kerning0 
\hich\af1\dbch\af17\loch\f1 , }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Ty\hich\af1\dbch\af17\loch\f1 pe }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 )
\par }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 Constant ::= }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 intConstant }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 doubleConstant }{
\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 boolConstant }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 |
\par }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 stringConstant }{\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 | }{\b\f1\fs20\kerning0 \hich\af1\dbch\af17\loch\f1 null}{\fs20\kerning0 
\par }{\fs24\kerning0 
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Program structure
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 A Decaf program is a sequence of declarations, where each declaration establishes a variable, class,or function. The term }{\i\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 declaration }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 usually refers to\hich\af0\dbch\af17\loch\f0  a statement that establishes the identity of a name whereas }{\i\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 definition }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
means the full description (i.e. the difference between just a function prototype and a version with the actual body). For variables and classes, the declaration and the definition are\hich\af0\dbch\af17\loch\f0 
 one and the same. For functions, it is possible to have separate declarations and definitions.
\par \hich\af0\dbch\af17\loch\f0 A program must have a global function named }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 main }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
that takes no arguments and returns void. This function serves as the entry point for program execution.
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Scopin\hich\af1\dbch\af17\loch\f1 g
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf has simple scope rules. All identifiers must be defined (textually) before use. For example:
\par \hich\af0\dbch\af17\loch\f0 - a variable must be declared before it is used
\par \hich\af0\dbch\af17\loch\f0 - a function can be called only by code appearing after its declaration or definition
\par \hich\af0\dbch\af17\loch\f0 - a class can only be\hich\af0\dbch\af17\loch\f0  used in a declaration appearing after the name of the class has been defined
\par \hich\af0\dbch\af17\loch\f0 Decaf supports several levels of scoping. A declaration at the top-level is placed in the global scope.Each class definition has its own class scope. Each function has a local sc\hich\af0\dbch\af17\loch\f0 
ope for its parameter list and another local scope for its body. A set of curly braces within a local scope establishes a nested local scope. Inner scopes shadow outer scopes; for example, a variable defined in a function's scope masks another variable wi
\hich\af0\dbch\af17\loch\f0 t\hich\af0\dbch\af17\loch\f0 h the same name in the global scope. Similarly, functions defined in class scope shadow global functions of the same name.
\par \bullet \hich\af0\dbch\af17\loch\f0  all variables, functions, and classes must be declared to prior to use
\par \bullet \hich\af0\dbch\af17\loch\f0  identifiers within a scope must be unique (i.e. cannot hav\hich\af0\dbch\af17\loch\f0 e two functions of same name, a global variable and function of the same name, a global variable and a class of the same name, etc.)

\par \bullet \hich\af0\dbch\af17\loch\f0  identifiers re-declared or re-defined with a nested scope shadow the version in the outer scope (i.e. it is legal to have\hich\af0\dbch\af17\loch\f0 
 a local variable with the same name as a global variable, a function within a class can have the same name as a global function, and so on.)
\par \bullet \hich\af0\dbch\af17\loch\f0  declarations in the global scope are accessible anywhere in the program (unless they are
\par \hich\af0\dbch\af17\loch\f0 shadowed by another use\hich\af0\dbch\af17\loch\f0  of the identifier)
\par \bullet \hich\af0\dbch\af17\loch\f0  declarations in closed scopes are inaccessible
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Variables
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Variables can be declared of non-void base type, array type, or class type. Variables declared outside any function have global scope. Variables declared within a class definiti\hich\af0\dbch\af17\loch\f0 
on yet outside a function have class scope. Variables declared in the formal parameter list or function body have local scope. Once declared, a variable is visible until that scope is closed.
\par \bullet \hich\af0\dbch\af17\loch\f0  a variable declared of class type must refer to a defined clas\hich\af0\dbch\af17\loch\f0 s name
\par \bullet \hich\af0\dbch\af17\loch\f0  local variables can be declared anywhere within a statement sequence and are accessible at the point of declaration and on until the scope of declaration is closed
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Arrays
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf arrays are homogenous, linearly indexed collections. Arrays are implem\hich\af0\dbch\af17\loch\f0 
ented as references(pointers). Arrays are declared without size information, and all arrays are dynamically allocated in the heap to the needed size using the built-in }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 NewArray }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 operator.
\par \bullet \hich\af0\dbch\af17\loch\f0  arrays can be declared of any non-void base type, defined class typ\hich\af0\dbch\af17\loch\f0 e, or array type (including array of arrays)
\par \bullet \hich\af0\dbch\af17\loch\f0  }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 NewArray(N, type) }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
allocates a new array of the specified type and number of elements, where N must be an integer and strictly positive
\par \bullet \hich\af0\dbch\af17\loch\f0  the number of elements in an array is set when allocated and cannot be c\hich\af0\dbch\af17\loch\f0 hanged once allocated
\par \bullet \hich\af0\dbch\af17\loch\f0  arrays support the special syntax }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 arr.length() }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 to retrieve the number of elements in an array
\par \bullet \hich\af0\dbch\af17\loch\f0  array indexing can only be applied to a variable of an array type
\par \bullet \hich\af0\dbch\af17\loch\f0  array elements are indexed from 0 to length-1
\par \bullet \hich\af0\dbch\af17\loch\f0  the index used in an\hich\af0\dbch\af17\loch\f0  array selection expression must be of integer type
\par \bullet \hich\af0\dbch\af17\loch\f0  a runtime error is reported when indexing a location that is outside the bounds for the array
\par \bullet \hich\af0\dbch\af17\loch\f0  arrays may be passed as parameters and returned from functions. The array itself is passed by value, but i\hich\af0\dbch\af17\loch\f0 
t is a reference and thus changes to array elements are seen in the calling function.
\par \bullet \hich\af0\dbch\af17\loch\f0  array assignment is shallow (i.e. assigning one array to another copies just the reference)
\par \bullet \hich\af0\dbch\af17\loch\f0  array comparison (== and !=) only compares the references for equality
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Str\hich\af1\dbch\af17\loch\f1 ings
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 String support is somewhat sparse in Decaf. Programs can include string constants, read strings
\par \hich\af0\dbch\af17\loch\f0 from the user with the built-in }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ReadLine }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
function, compare strings, and print strings, but that's about it. There is no support for programmatically creati\hich\af0\dbch\af17\loch\f0 
ng and manipulating strings, converting between strings and other types, and so on.(Consider it an opportunity for extension!) Strings are implemented as references (pointers).
\par \bullet \hich\af0\dbch\af17\loch\f0  }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ReadLine() }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 reads a sequence of chars entered by the user, up to but not inclu\hich\af0\dbch\af17\loch\f0 ding the newline

\par \bullet \hich\af0\dbch\af17\loch\f0  string assignment is shallow (i.e. assigning one string to another copies just the reference)
\par \bullet \hich\af0\dbch\af17\loch\f0  strings may be passed as parameters and returned from functions
\par \bullet \hich\af0\dbch\af17\loch\f0  string comparison (== and !=) compares the sequence of characters in the tw\hich\af0\dbch\af17\loch\f0 o strings in a casesensitive manner
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Function declaration and definition
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 A function declaration serves to establish the name of the function and its associated }{\i\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 type signature}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
, which includes the function return type as well as number and types of formal par\hich\af0\dbch\af17\loch\f0 ameters. A function definition provides the type signature and the statements that make up the function body.
\par \bullet \hich\af0\dbch\af17\loch\f0  functions are either global or declared within a class scope; functions may not be nested within other functions
\par \bullet \hich\af0\dbch\af17\loch\f0  the function may have zero or\hich\af0\dbch\af17\loch\f0  more formal parameters
\par \bullet \hich\af0\dbch\af17\loch\f0  formal parameters can be of non-void base type, array type, or class type
\par \bullet \hich\af0\dbch\af17\loch\f0  identifiers used in the formal parameter list must be distinct
\par \bullet \hich\af0\dbch\af17\loch\f0  the formal parameters are declared in a separate scope from the function\hich\f0 \rquote \loch\f0 s local variable\hich\af0\dbch\af17\loch\f0 s (thus, a local variable can shadow a parameter)
\par \bullet \hich\af0\dbch\af17\loch\f0  the function return type can be any base, array, or class type. void type is used to indicate the function returns no value.
\par \bullet \hich\af0\dbch\af17\loch\f0  a function declaration and its definition must have same type signature
\par \bullet \hich\af0\dbch\af17\loch\f0  mul\hich\af0\dbch\af17\loch\f0 tiple declarations of a function are allowed (as long as they match), but a function can only be defined once
\par \bullet \hich\af0\dbch\af17\loch\f0  function overloading is not allowed i.e., the use of the same name for functions with different type signatures
\par \bullet \hich\af0\dbch\af17\loch\f0  if a function has a non-void r\hich\af0\dbch\af17\loch\f0 eturn type, any return statement must return a value compatible with that type
\par \bullet \hich\af0\dbch\af17\loch\f0  if a function has a void return type, it may only use the empty return statement
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Function invocation
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Function invocation involves passing argument values from the caller to th\hich\af0\dbch\af17\loch\f0 
e callee, executing the body of the callee, and returning to the caller, possibly with a result. When a function is invoked, the actual arguments are evaluated and bound to the formal parameters. All Decaf parameters and return values are passed by value.

\par \bullet \hich\af0\dbch\af17\loch\f0  all functions must be declared before being called
\par \bullet \hich\af0\dbch\af17\loch\f0  the number of actual arguments in a function call must match the number of formal parameters
\par \bullet \hich\af0\dbch\af17\loch\f0  the type of each actual argument in a function call must be compatible with the formal parameter
\par \bullet \hich\af0\dbch\af17\loch\f0  the act\hich\af0\dbch\af17\loch\f0 ual arguments to a function call are evaluated from left to right
\par \bullet \hich\af0\dbch\af17\loch\f0  a function call returns control to the caller on a return statement or when the textual end of the callee is reached
\par \bullet \hich\af0\dbch\af17\loch\f0  a function call evaluates to the type of the function's declared retu\hich\af0\dbch\af17\loch\f0 rn type
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Classes
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
Defining a class creates a new type name and a class scope. A class definition is a list of fields, where each field is either a variable or function. The variables of a class are also sometimes called instance variables or member data and 
\hich\af0\dbch\af17\loch\f0 the functions are called methods or member functions.
\par \hich\af0\dbch\af17\loch\f0 Decaf enforces object encapsulation through a simple mechanism: all variables are private (scoped to the class and its subclasses, Java calls this access level protected, by the way) and all methods are
\hich\af0\dbch\af17\loch\f0  public (accessible in global scope). Thus, the only way to gain access to object state is via methods.
\par \bullet \hich\af0\dbch\af17\loch\f0  all class definitions are global, i.e., classes may not be defined inside a function
\par \bullet \hich\af0\dbch\af17\loch\f0  all classes must have unique names
\par \bullet \hich\af0\dbch\af17\loch\f0  a field name can be used a\hich\af0\dbch\af17\loch\f0 t most once within a class scope (i.e. cannot have two methods of the same name or a variable and method of the same name)
\par \bullet \hich\af0\dbch\af17\loch\f0  fields must be declared before use (i.e. unlike Java where you can refer to fields that won\hich\f0 \rquote \loch\f0 t be declared until later in the class \hich\af0\dbch\af17\loch\f0 
definition, Decaf requires those fields to be declared before used within the class definition)
\par \bullet \hich\af0\dbch\af17\loch\f0  instance variables can be of non-void base type, array type, or class type
\par \bullet \hich\af0\dbch\af17\loch\f0 \hich\f0  the use of \'93\loch\f0 \hich\f0 this.\'94\loch\f0  is optional when accessing fields within a method
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Objects
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 A va\hich\af0\dbch\af17\loch\f0 
riable of class type is called an object or an instance of that class. Objects are implemented as references. All objects are dynamically allocated in the heap using the built-in }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 New }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 operator.
\par \bullet \hich\af0\dbch\af17\loch\f0  the class name used in an object variable declaration must be\hich\af0\dbch\af17\loch\f0  a defined class name
\par \bullet \hich\af0\dbch\af17\loch\f0  the argument to }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 New }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 must be a defined class name
\par \bullet \hich\af0\dbch\af17\loch\f0  the . operator is used to access the fields (both variables and methods) of an object
\par \bullet \hich\af0\dbch\af17\loch\f0  for method invocations of the form }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 expr.method(), }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 the type of }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 expr }{
\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 must be some class }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 T}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 meth\hich\af6\dbch\af17\loch\f6 od }{
\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 must name one of }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 T }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 's methods
\par \bullet \hich\af0\dbch\af17\loch\f0  for variable access of the form }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 expr.var}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , the type of }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 expr }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 must be some }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 class T}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 var }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
must name one of }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 T }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 's variables, and this access must appear with the scope of class }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 T }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 or one of its subclasses
\par \bullet \hich\af0\dbch\af17\loch\f0  Additional note on tha\hich\af0\dbch\af17\loch\f0 
t last one: inside class scope, you can access the private variables of the receiving object as well as other instances of that class or its subclasses, but cannot access the variables of other unrelated classes.
\par \bullet \hich\af0\dbch\af17\loch\f0  object assignment is shallow (i.e. assign\hich\af0\dbch\af17\loch\f0 ing one object to another copies just the reference)
\par \bullet \hich\af0\dbch\af17\loch\f0  objects may be passed as parameters and returned from functions. The object itself is passed by value, but it is a reference and thus changes to its variables are seen in the calling function.
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Inherita\hich\af1\dbch\af17\loch\f1 nce
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
Decaf supports single inheritance, allowing a derived class to extend a base class by adding additional fields and overriding existing methods with new definitions. The semantics of A extends B is that A has all the fields (both variables and functions
\hich\af0\dbch\af17\loch\f0 ) defined in B in addition to its own fields.
\par \hich\af0\dbch\af17\loch\f0 A subclass can override an inherited method (replace with redefinition) but the inherited version must match the original in return type and parameter types. Decaf supports automatic upcasting so that an object
\hich\af0\dbch\af17\loch\f0  of a derived class type can be provided whenever an object of its base class type is expected.
\par \hich\af0\dbch\af17\loch\f0 All Decaf methods are dynamically dispatched (i.e. }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 virtual }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
for you C++ folks). The compiler cannot determine the exact address of the method that should be call\hich\af0\dbch\af17\loch\f0 
ed at compile-time (i.e.consider invoking an overridden method on an upcasted object), so instead the dispatch is handled at runtime by consulting a method table associated with each object. We will discuss dispatch tables in more detail later on.
\par \bullet \hich\af0\dbch\af17\loch\f0  if spe\hich\af0\dbch\af17\loch\f0 cified, the parent of a class must be a defined class type
\par \bullet \hich\af0\dbch\af17\loch\f0  all of the fields (both variables and methods) of the parent class are inherited by the subclass
\par \bullet \hich\af0\dbch\af17\loch\f0  subclasses cannot override inherited variables
\par \bullet \hich\af0\dbch\af17\loch\f0  a subclass can override an inherited method (re\hich\af0\dbch\af17\loch\f0 place with redefinition) but the inherited must match the original in return type and parameter types
\par \bullet \hich\af0\dbch\af17\loch\f0  no overloading: a class can not reuse the same name for another method with a different type signature (whether inherited or not)
\par \bullet \hich\af0\dbch\af17\loch\f0  an instance of subcl\hich\af0\dbch\af17\loch\f0 
ass type is compatible with its parent type, and can be substituted for an expression of a parent type (e.g. if a variable is declared of type class Animal , you can assign it from a right-hand side expression of type class Cow if Cow is a subclass of Ani
\hich\af0\dbch\af17\loch\f0 m\hich\af0\dbch\af17\loch\f0 al. Similarly,\hich\af0\dbch\af17\loch\f0 if the Binky function takes a parameter of type class Animal, it is acceptable to pass a variable of\hich\af0\dbch\af17\loch\f0  
\hich\af0\dbch\af17\loch\f0 type class Cow or return a Cow from a function that returns an Animal). The inverse is not true\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 (the parent cannot be substituted where the \hich\af0\dbch\af17\loch\f0 
subclass is expected).
\par \bullet \hich\af0\dbch\af17\loch\f0  the previous rule applies across multiple levels of inheritance as well
\par \bullet \hich\af0\dbch\af17\loch\f0  it is the compile-time declared type of an object that determines its class for checking for fields\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 (i.e. once you have upcast a Cow to an Animal variable, y
\hich\af0\dbch\af17\loch\f0 ou cannot access Cow-specific\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 additions from that variable)
\par \bullet \hich\af0\dbch\af17\loch\f0  there is no subtyping of array types: if T2 extends T1, an array of T2[\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 ] is not compatible with\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
an array of T1[\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 ] (this is unlike Java).
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Type equivalence and compatibility
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf is a (mostly) str\hich\af0\dbch\af17\loch\f0 ongly-typed language: a specific type is associated with each variable, and the\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
variable may contain only values belonging to that type\hich\f0 \rquote \loch\f0 s range of values. If type A is equivalent to\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
B, an expression of either type can be freely substituted for the other in\hich\af0\dbch\af17\loch\f0  any situation. Two base\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
types are equivalent if and only if they are the same exact type. Two array types are equivalent if\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
and only if they have the same element type (which itself may be an array, thus implying a recursive\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 definition of structural equiv\hich\af0\dbch\af17\loch\f0 
alence is used here). Two class types are equivalent if and only if they
\par \hich\af0\dbch\af17\loch\f0 are the same exact type (i.e. named equivalence not structural).
\par 
\par \hich\af0\dbch\af17\loch\f0 Type compatibility is a more limited unidirectional relationship. If Type A is compatible with B,\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 then an expression o\hich\af0\dbch\af17\loch\f0 
f type A can be substituted where an expression of type B was expected.\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 Nothing is implied about the reverse direction. Two equivalent types are type compatible in both\hich\af0\dbch\af17\loch\f0  
\hich\af0\dbch\af17\loch\f0 directions. A subclass is compatible with its parent type, but not the reverse. The nul\hich\af0\dbch\af17\loch\f0 l type is\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
compatible with all class types. Operations such as assignment and parameter passing allow for not\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 just equivalent types but compatible types.
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Assignment
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 For the base types, Decaf uses value-copy semantics; the assignment }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 LValue = Expr }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 copies the
\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 value resulting from the evaluation of }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 Expr }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 into the location indicated by }{\f6\fs20\kerning0 
\hich\af6\dbch\af17\loch\f6 LValue}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 . For arrays,\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 objects and strings, Decaf uses reference-copy semantics; the assignment }{\f6\fs20\kerning0 
\hich\af6\dbch\af17\loch\f6 LValue = Expr }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 causes\hich\af0\dbch\af17\loch\f0  }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 LValue }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 
to contain a reference to the object resulting from the eva\hich\af0\dbch\af17\loch\f0 luation of }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 Expr }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (i.e., the\hich\af0\dbch\af17\loch\f0  
\hich\af0\dbch\af17\loch\f0 assignment copies a pointer to an object rather than the object). Said another way, assignment for\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 arrays, objects, and strings makes a shallow, not deep, copy.
\par \bullet \hich\af0\dbch\af17\loch\f0  an LValue must be an assignable variable location
\par \bullet \hich\af0\dbch\af17\loch\f0  the right side\hich\af0\dbch\af17\loch\f0  type of an assignment statement must be compatible with the left side type
\par \bullet \hich\af0\dbch\af17\loch\f0  null can only be assigned to a variable of class type
\par \bullet \hich\af0\dbch\af17\loch\f0  it is legal to assign to the formal parameters within a function, such assignments affect only the\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 function scope
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Contro\hich\af1\dbch\af17\loch\f1 l structures
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf control structures are based on the C/Java versions and generally behave somewhat similarly.
\par \bullet \hich\af0\dbch\af17\loch\f0  An }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 else }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 clause always joins with the closest unclosed }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 if }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 statement
\par \bullet \hich\af0\dbch\af17\loch\f0  the expression in the test portions of the }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 if while }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 and }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 for }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 statements mu\hich\af0\dbch\af17\loch\f0 st have bool type
\par \bullet \hich\af0\dbch\af17\loch\f0  a }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 break }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 statement can only appear within a }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 while }{\fs24\kerning0 
\hich\af0\dbch\af17\loch\f0 or }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 for }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 loop
\par \bullet \hich\af0\dbch\af17\loch\f0  the value in a }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 return }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 statement must be compatible with return type of the enclosing function
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Expressions
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 For simplicity, Decaf does not allow co-mingling and conversion of \hich\af0\dbch\af17\loch\f0 types within expressions (i.e.\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
adding an integer to a double, using an integer as a boolean, etc.).
\par \bullet \hich\af0\dbch\af17\loch\f0  constants evaluate to themselves (true, false, null, integers, doubles, string literals)
\par \bullet \hich\af0\dbch\af17\loch\f0  }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 this }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is bound to the receiving object within class scope, it is\hich\af0\dbch\af17\loch\f0  an error outside class scope

\par \bullet \hich\af0\dbch\af17\loch\f0  the two operands to binary arithmetic operators (+,-,*, and /) must either be both int or both\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 double. The result is of the same type as the operands.
\par \bullet \hich\af0\dbch\af17\loch\f0  the two operands to % must both be int. The result type is int.
\par \bullet \hich\af0\dbch\af17\loch\f0  the o\hich\af0\dbch\af17\loch\f0 perand to a unary minus must be int or double. The result is the same type as the operand.
\par \bullet \hich\af0\dbch\af17\loch\f0  the two operands to binary relational operators (<, >, <=, >=) must either both be int or both\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 double. The result type is bool.
\par \bullet \hich\af0\dbch\af17\loch\f0  the two operands to binary equali\hich\af0\dbch\af17\loch\f0 ty operators (!=, ==) must be of equivalent type (two ints, two\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
arrays of double, etc.) (see exception below for objects) The result type is bool
\par \bullet \hich\af0\dbch\af17\loch\f0  the two operands to binary equality operands can also be two objects or an object and null. The\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 types of the\hich\af0\dbch\af17\loch\f0 
 two objects must be compatible in at least one direction. The result type is bool.
\par \bullet \hich\af0\dbch\af17\loch\f0  the operands to all logical operators must be of bool type. The result type is bool.
\par \bullet \hich\af0\dbch\af17\loch\f0  logical and and or do not short-circuit; both expressions are evaluated before dete\hich\af0\dbch\af17\loch\f0 rmining the\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 result
\par \bullet \hich\af0\dbch\af17\loch\f0  the operands for all expressions are evaluated left to right\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 Operator precedence from highest to lowest:
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 [ . }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (array indexing and field selection)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ! - }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (unary -, logical not)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 * / % }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (multiply, divide, mod)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 + - }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (addition, subtraction)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 < <=\hich\af6\dbch\af17\loch\f6  > >= }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (relational)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 == != }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (equality)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 && }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (logical and)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 || }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (logical or)
\par }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 = }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (assignment)
\par 
\par \hich\af0\dbch\af17\loch\f0 All binary arithmetic operators and both binary logical operators are left-associative. Assignment\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
and the relational operators do not associate (i.e. you cannot chain a se\hich\af0\dbch\af17\loch\f0 quence of these operators\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 that are at the same precedence level: }{\f6\fs20\kerning0 
\hich\af6\dbch\af17\loch\f6 a < b >= c }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 or }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 a = b = c }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 should not parse, however }{\f6\fs20\kerning0 
\hich\af6\dbch\af17\loch\f6 a < b\hich\af6\dbch\af17\loch\f6  \hich\af6\dbch\af17\loch\f6 == c }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is okay). Parentheses may be used to override the precedence and/or associativity.
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Standard library functions
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf has a very sma\hich\af0\dbch\af17\loch\f0 ll set of routines in its standard library that allows for simple I/O and memory\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
allocation. The library functions are }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 Print}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ReadInteger}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , }{
\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ReadLine}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 New}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 , and }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 
NewArray}{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 .
\par \bullet \hich\af0\dbch\af17\loch\f0  the arguments passed to a }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 Print }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 statement can only be string, int, or bool
\par \bullet \hich\af0\dbch\af17\loch\f0  the arg\hich\af0\dbch\af17\loch\f0 ument to }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 New }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 must be a defined class name
\par \bullet \hich\af0\dbch\af17\loch\f0  the first argument to }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 NewArray }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 must be of integer type, the second any non-void type
\par \bullet \hich\af0\dbch\af17\loch\f0  the return type for }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 NewArray }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 is array of T where T is the type specified as the second argument
\par \bullet \hich\af0\dbch\af17\loch\f0  }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ReadLine() }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 reads a sequence\hich\af0\dbch\af17\loch\f0  of chars entered by the user, up to but not including the newline

\par \bullet \hich\af0\dbch\af17\loch\f0  }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 ReadInteger() }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 reads a line of text entered by the user, and converts to an integer using }{\f6\fs20\kerning0 
\hich\af6\dbch\af17\loch\f6 atoi\hich\af6\dbch\af17\loch\f6  }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 (returns 0 if the user didn't enter a valid number)
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Decaf "linking"
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 Decaf requires that every\hich\af0\dbch\af17\loch\f0  function/method that was used must be eventually defined. A function\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
declaration allows for calls to that function to compile, but in order to finish compilation\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 successfully, the function definition must eventually be provided.
\par \bullet \hich\af0\dbch\af17\loch\f0  any function or method t\hich\af0\dbch\af17\loch\f0 hat is called must have a definition
\par \bullet \hich\af0\dbch\af17\loch\f0  a declaration for an undefined function that is never used is not considered an error
\par \bullet \hich\af0\dbch\af17\loch\f0  there must be a definition for the global function }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 main
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Run time checks
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 There are only two runtime checks that are supported by D\hich\af0\dbch\af17\loch\f0 ecaf (leaving lots of room for
\par \hich\af0\dbch\af17\loch\f0 extension!).
\par \bullet \hich\af0\dbch\af17\loch\f0  the subscript of an array must be in bounds, i.e. in range 0 . . arr.length() \hich\f0 \endash \loch\f0 1
\par \bullet \hich\af0\dbch\af17\loch\f0  the size passed to }{\f6\fs20\kerning0 \hich\af6\dbch\af17\loch\f6 NewArray }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 must be non-negative
\par \hich\af0\dbch\af17\loch\f0 When a run-time errors occurs, an appropriate error message is output to the t\hich\af0\dbch\af17\loch\f0 erminal and the\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 program terminates.
\par }{\b\f1\fs24\kerning0 \hich\af1\dbch\af17\loch\f1 Things Decaf doesn't do!
\par }{\fs24\kerning0 \hich\af0\dbch\af17\loch\f0 By design, Decaf is a simple language and although it has all the features necessary to write a wide\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
variety of object-oriented programs, there are various things that C++ and Java compilers do t\hich\af0\dbch\af17\loch\f0 hat it\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 does not. Here are a few that come to mind
\par \bullet \hich\af0\dbch\af17\loch\f0  doesn't mandate what the values for uninitialized variables are or what the value of variables or\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 elements in a newly allocated object or array are
\par \bullet \hich\af0\dbch\af17\loch\f0  doesn't check for use of uninitialized variables
\par \bullet \hich\af0\dbch\af17\loch\f0  doe\hich\af0\dbch\af17\loch\f0 sn't detect (either compile or runtime) a function that is declared to return a value but fails to\hich\af0\dbch\af17\loch\f0  \hich\af0\dbch\af17\loch\f0 
do so before falling off the textual end of the body
\par \bullet \hich\af0\dbch\af17\loch\f0  doesn't check for an object or array use before it was ever allocated
\par \bullet \hich\af0\dbch\af17\loch\f0  doesn't detect call methods or\hich\af0\dbch\af17\loch\f0  accessing variables of a null object
\par \bullet \hich\af0\dbch\af17\loch\f0  doesn't detect unreachable code
\par \bullet \hich\af0\dbch\af17\loch\f0  has no deallocation function and no garbage collection, so dynamic storage is never reclaimed
\par \bullet \hich\af0\dbch\af17\loch\f0  no support for object constructors or destructors
\par \bullet \hich\af0\dbch\af17\loch\f0 \hich\f0  and many others\'85
\par }{\fs20\kerning0 
\par }}