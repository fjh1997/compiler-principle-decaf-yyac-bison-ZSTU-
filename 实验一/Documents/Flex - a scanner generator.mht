From: <ÓÉ Microsoft Internet Explorer 5 ±£´æ>
Subject: Flex - a scanner generator
Date: Tue, 17 Jun 2003 02:10:45 +0800
MIME-Version: 1.0
Content-Type: text/html;
	charset="gb2312"
Content-Transfer-Encoding: quoted-printable
Content-Location: http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html
X-MimeOLE: Produced By Microsoft MimeOLE V6.00.2800.1106

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Flex - a scanner generator</TITLE>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Dgb2312"><!-- Created by texi2html 1.56k from flex.texi on 23 =
February 2001 -->
<META content=3D"MSHTML 6.00.2800.1106" name=3DGENERATOR></HEAD>
<BODY>
<H1>Flex, version 2.5</H1>
<H2>A fast scanner generator</H2>
<H2>Edition 2.5, March 1995</H2>
<ADDRESS>Vern Paxson</ADDRESS>
<P>
<P>
<HR>

<P>
<H1>Table of Contents</H1>
<UL>
  <UL>
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC1"=20
    name=3DTOC1>Name</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC2"=20
    name=3DTOC2>Synopsis</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC3"=20
    name=3DTOC3>Overview</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC4"=20
    name=3DTOC4>Description</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC5"=20
    name=3DTOC5>Some simple examples</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC6"=20
    name=3DTOC6>Format of the input file</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC7"=20
    name=3DTOC7>Patterns</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC8"=20
    name=3DTOC8>How the input is matched</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC9"=20
    name=3DTOC9>Actions</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC10"=20
    name=3DTOC10>The generated scanner</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC11"=20
    name=3DTOC11>Start conditions</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC12"=20
    name=3DTOC12>Multiple input buffers</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC13"=20
    name=3DTOC13>End-of-file rules</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC14"=20
    name=3DTOC14>Miscellaneous macros</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC15"=20
    name=3DTOC15>Values available to the user</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC16"=20
    name=3DTOC16>Interfacing with <CODE>yacc</CODE></A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC17"=20
    name=3DTOC17>Options</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC18"=20
    name=3DTOC18>Performance considerations</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC19"=20
    name=3DTOC19>Generating C++ scanners</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC20"=20
    name=3DTOC20>Incompatibilities with <CODE>lex</CODE> and POSIX</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC21"=20
    name=3DTOC21>Diagnostics</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC22"=20
    name=3DTOC22>Files</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC23"=20
    name=3DTOC23>Deficiencies / Bugs</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC24"=20
    name=3DTOC24>See also</A>=20
    <LI><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#SEC25"=20
    name=3DTOC25>Author</A> </LI></UL></UL>
<P>
<HR>

<P>
<P>Copyright (C) 1990 The Regents of the University of California. All =
rights=20
reserved.=20
<P>This code is derived from software contributed to Berkeley by Vern =
Paxson.=20
<P>The United States Government has rights in this work pursuant to =
contract no.=20
DE-AC03-76SF00098 between the United States Department of Energy and the =

University of California.=20
<P>Redistribution and use in source and binary forms with or without=20
modification are permitted provided that: (1) source distributions =
retain this=20
entire copyright notice and comment, and (2) distributions including =
binaries=20
display the following acknowledgement: "This product includes software =
developed=20
by the University of California, Berkeley and its contributors" in the=20
documentation or other materials provided with the distribution and in =
all=20
advertising materials mentioning features or use of this software. =
Neither the=20
name of the University nor the names of its contributors may be used to =
endorse=20
or promote products derived from this software without specific prior =
written=20
permission.=20
<P>THIS SOFTWARE IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED=20
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF=20
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC1"=20
name=3DSEC1>Name</A></H2>
<P>flex - fast lexical analyzer generator=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC2"=20
name=3DSEC2>Synopsis</A></H2><PRE>flex [-bcdfhilnpstvwBFILTV78+? =
-C[aefFmr] -ooutput -Pprefix -Sskeleton]
[--help --version] [<VAR>filename</VAR> ...]
</PRE>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC3"=20
name=3DSEC3>Overview</A></H2>
<P>This manual describes <CODE>flex</CODE>, a tool for generating =
programs that=20
perform pattern-matching on text. The manual includes both tutorial and=20
reference sections:=20
<DL compact>
  <DT>Description=20
  <DD>a brief overview of the tool=20
  <DT>Some Simple Examples=20
  <DD>
  <DT>Format Of The Input File=20
  <DD>
  <DT>Patterns=20
  <DD>the extended regular expressions used by flex=20
  <DT>How The Input Is Matched=20
  <DD>the rules for determining what has been matched=20
  <DT>Actions=20
  <DD>how to specify what to do when a pattern is matched=20
  <DT>The Generated Scanner=20
  <DD>details regarding the scanner that flex produces; how to control =
the input=20
  source=20
  <DT>Start Conditions=20
  <DD>introducing context into your scanners, and managing =
"mini-scanners"=20
  <DT>Multiple Input Buffers=20
  <DD>how to manipulate multiple input sources; how to scan from strings =
instead=20
  of files=20
  <DT>End-of-file Rules=20
  <DD>special rules for matching the end of the input=20
  <DT>Miscellaneous Macros=20
  <DD>a summary of macros available to the actions=20
  <DT>Values Available To The User=20
  <DD>a summary of values available to the actions=20
  <DT>Interfacing With Yacc=20
  <DD>connecting flex scanners together with yacc parsers=20
  <DT>Options=20
  <DD>flex command-line options, and the "%option" directive=20
  <DT>Performance Considerations=20
  <DD>how to make your scanner go as fast as possible=20
  <DT>Generating C++ Scanners=20
  <DD>the (experimental) facility for generating C++ scanner classes=20
  <DT>Incompatibilities With Lex And POSIX=20
  <DD>how flex differs from AT&amp;T lex and the POSIX lex standard=20
  <DT>Diagnostics=20
  <DD>those error messages produced by flex (or scanners it generates) =
whose=20
  meanings might not be apparent=20
  <DT>Files=20
  <DD>files used by flex=20
  <DT>Deficiencies / Bugs=20
  <DD>known problems with flex=20
  <DT>See Also=20
  <DD>other documentation, related tools=20
  <DT>Author=20
  <DD>includes contact information </DD></DL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC4"=20
name=3DSEC4>Description</A></H2>
<P><CODE>flex</CODE> is a tool for generating <EM>scanners</EM>: =
programs which=20
recognized lexical patterns in text. <CODE>flex</CODE> reads the given =
input=20
files, or its standard input if no file names are given, for a =
description of a=20
scanner to generate. The description is in the form of pairs of regular=20
expressions and C code, called <EM>rules</EM>. <CODE>flex</CODE> =
generates as=20
output a C source file, <TT>`lex.yy.c'</TT>, which defines a routine=20
<SAMP>`yylex()'</SAMP>. This file is compiled and linked with the=20
<SAMP>`-lfl'</SAMP> library to produce an executable. When the =
executable is=20
run, it analyzes its input for occurrences of the regular expressions. =
Whenever=20
it finds one, it executes the corresponding C code.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC5"=20
name=3DSEC5>Some simple examples</A></H2>
<P>First some simple examples to get the flavor of how one uses=20
<CODE>flex</CODE>. The following <CODE>flex</CODE> input specifies a =
scanner=20
which whenever it encounters the string "username" will replace it with =
the=20
user's login name: <PRE>%%
username    printf( "%s", getlogin() );
</PRE>
<P>By default, any text not matched by a <CODE>flex</CODE> scanner is =
copied to=20
the output, so the net effect of this scanner is to copy its input file =
to its=20
output with each occurrence of "username" expanded. In this input, there =
is just=20
one rule. "username" is the <VAR>pattern</VAR> and the "printf" is the=20
<VAR>action</VAR>. The "%%" marks the beginning of the rules.=20
<P>Here's another simple example: <PRE>        int num_lines =3D 0, =
num_chars =3D 0;

%%
\n      ++num_lines; ++num_chars;
.       ++num_chars;

%%
main()
        {
        yylex();
        printf( "# of lines =3D %d, # of chars =3D %d\n",
                num_lines, num_chars );
        }
</PRE>
<P>This scanner counts the number of characters and the number of lines =
in its=20
input (it produces no output other than the final report on the counts). =
The=20
first line declares two globals, "num_lines" and "num_chars", which are=20
accessible both inside <SAMP>`yylex()'</SAMP> and in the =
<SAMP>`main()'</SAMP>=20
routine declared after the second "%%". There are two rules, one which =
matches a=20
newline ("\n") and increments both the line count and the character =
count, and=20
one which matches any character other than a newline (indicated by the =
"."=20
regular expression).=20
<P>A somewhat more complicated example: <PRE>/* scanner for a toy =
Pascal-like language */

%{
/* need this for the call to atof() below */
#include &lt;math.h&gt;
%}

DIGIT    [0-9]
ID       [a-z][a-z0-9]*

%%

{DIGIT}+    {
            printf( "An integer: %s (%d)\n", yytext,
                    atoi( yytext ) );
            }

{DIGIT}+"."{DIGIT}*        {
            printf( "A float: %s (%g)\n", yytext,
                    atof( yytext ) );
            }

if|then|begin|end|procedure|function        {
            printf( "A keyword: %s\n", yytext );
            }

{ID}        printf( "An identifier: %s\n", yytext );

"+"|"-"|"*"|"/"   printf( "An operator: %s\n", yytext );

"{"[^}\n]*"}"     /* eat up one-line comments */

[ \t\n]+          /* eat up whitespace */

.           printf( "Unrecognized character: %s\n", yytext );

%%

main( argc, argv )
int argc;
char **argv;
    {
    ++argv, --argc;  /* skip over program name */
    if ( argc &gt; 0 )
            yyin =3D fopen( argv[0], "r" );
    else
            yyin =3D stdin;

    yylex();
    }
</PRE>
<P>This is the beginnings of a simple scanner for a language like =
Pascal. It=20
identifies different types of <VAR>tokens</VAR> and reports on what it =
has seen.=20

<P>The details of this example will be explained in the following =
sections.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC6"=20
name=3DSEC6>Format of the input file</A></H2>
<P>The <CODE>flex</CODE> input file consists of three sections, =
separated by a=20
line with just <SAMP>`%%'</SAMP> in it: <PRE>definitions
%%
rules
%%
user code
</PRE>
<P>The <EM>definitions</EM> section contains declarations of simple=20
<EM>name</EM> definitions to simplify the scanner specification, and=20
declarations of <EM>start conditions</EM>, which are explained in a =
later=20
section. Name definitions have the form: <PRE>name definition
</PRE>
<P>The "name" is a word beginning with a letter or an underscore ('_') =
followed=20
by zero or more letters, digits, '_', or '-' (dash). The definition is =
taken to=20
begin at the first non-white-space character following the name and =
continuing=20
to the end of the line. The definition can subsequently be referred to =
using=20
"{name}", which will expand to "(definition)". For example, <PRE>DIGIT   =
 [0-9]
ID       [a-z][a-z0-9]*
</PRE>
<P>defines "DIGIT" to be a regular expression which matches a single =
digit, and=20
"ID" to be a regular expression which matches a letter followed by =
zero-or-more=20
letters-or-digits. A subsequent reference to <PRE>{DIGIT}+"."{DIGIT}*
</PRE>
<P>is identical to <PRE>([0-9])+"."([0-9])*
</PRE>
<P>and matches one-or-more digits followed by a '.' followed by =
zero-or-more=20
digits.=20
<P>The <VAR>rules</VAR> section of the <CODE>flex</CODE> input contains =
a series=20
of rules of the form: <PRE>pattern   action
</PRE>
<P>where the pattern must be unindented and the action must begin on the =
same=20
line.=20
<P>See below for a further description of patterns and actions.=20
<P>Finally, the user code section is simply copied to =
<TT>`lex.yy.c'</TT>=20
verbatim. It is used for companion routines which call or are called by =
the=20
scanner. The presence of this section is optional; if it is missing, the =
second=20
<SAMP>`%%'</SAMP> in the input file may be skipped, too.=20
<P>In the definitions and rules sections, any <EM>indented</EM> text or =
text=20
enclosed in <SAMP>`%{'</SAMP> and <SAMP>`%}'</SAMP> is copied verbatim =
to the=20
output (with the <SAMP>`%{}'</SAMP>'s removed). The <SAMP>`%{}'</SAMP>'s =
must=20
appear unindented on lines by themselves.=20
<P>In the rules section, any indented or %{} text appearing before the =
first=20
rule may be used to declare variables which are local to the scanning =
routine=20
and (after the declarations) code which is to be executed whenever the =
scanning=20
routine is entered. Other indented or %{} text in the rule section is =
still=20
copied to the output, but its meaning is not well-defined and it may =
well cause=20
compile-time errors (this feature is present for <CODE>POSIX</CODE> =
compliance;=20
see below for other such features).=20
<P>In the definitions section (but not in the rules section), an =
unindented=20
comment (i.e., a line beginning with "/*") is also copied verbatim to =
the output=20
up to the next "*/".=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC7"=20
name=3DSEC7>Patterns</A></H2>
<P>The patterns in the input are written using an extended set of =
regular=20
expressions. These are:=20
<DL compact>
  <DT><SAMP>`x'</SAMP>=20
  <DD>match the character <SAMP>`x'</SAMP>=20
  <DT><SAMP>`.'</SAMP>=20
  <DD>any character (byte) except newline=20
  <DT><SAMP>`[xyz]'</SAMP>=20
  <DD>a "character class"; in this case, the pattern matches either an=20
  <SAMP>`x'</SAMP>, a <SAMP>`y'</SAMP>, or a <SAMP>`z'</SAMP>=20
  <DT><SAMP>`[abj-oZ]'</SAMP>=20
  <DD>a "character class" with a range in it; matches an =
<SAMP>`a'</SAMP>, a=20
  <SAMP>`b'</SAMP>, any letter from <SAMP>`j'</SAMP> through =
<SAMP>`o'</SAMP>,=20
  or a <SAMP>`Z'</SAMP>=20
  <DT><SAMP>`[^A-Z]'</SAMP>=20
  <DD>a "negated character class", i.e., any character but those in the =
class.=20
  In this case, any character EXCEPT an uppercase letter.=20
  <DT><SAMP>`[^A-Z\n]'</SAMP>=20
  <DD>any character EXCEPT an uppercase letter or a newline=20
  <DT><SAMP>`<VAR>r</VAR>*'</SAMP>=20
  <DD>zero or more <VAR>r</VAR>'s, where <VAR>r</VAR> is any regular =
expression=20
  <DT><SAMP>`<VAR>r</VAR>+'</SAMP>=20
  <DD>one or more <VAR>r</VAR>'s=20
  <DT><SAMP>`<VAR>r</VAR>?'</SAMP>=20
  <DD>zero or one <VAR>r</VAR>'s (that is, "an optional <VAR>r</VAR>")=20
  <DT><SAMP>`<VAR>r</VAR>{2,5}'</SAMP>=20
  <DD>anywhere from two to five <VAR>r</VAR>'s=20
  <DT><SAMP>`<VAR>r</VAR>{2,}'</SAMP>=20
  <DD>two or more <VAR>r</VAR>'s=20
  <DT><SAMP>`<VAR>r</VAR>{4}'</SAMP>=20
  <DD>exactly 4 <VAR>r</VAR>'s=20
  <DT><SAMP>`{<VAR>name</VAR>}'</SAMP>=20
  <DD>the expansion of the "<VAR>name</VAR>" definition (see above)=20
  <DT><SAMP>`"[xyz]\"foo"'</SAMP>=20
  <DD>the literal string: <SAMP>`[xyz]"foo'</SAMP>=20
  <DT><SAMP>`\<VAR>x</VAR>'</SAMP>=20
  <DD>if <VAR>x</VAR> is an <SAMP>`a'</SAMP>, <SAMP>`b'</SAMP>,=20
  <SAMP>`f'</SAMP>, <SAMP>`n'</SAMP>, <SAMP>`r'</SAMP>, =
<SAMP>`t'</SAMP>, or=20
  <SAMP>`v'</SAMP>, then the ANSI-C interpretation of \<VAR>x</VAR>. =
Otherwise,=20
  a literal <SAMP>`<VAR>x</VAR>'</SAMP> (used to escape operators such =
as=20
  <SAMP>`*'</SAMP>)=20
  <DT><SAMP>`\0'</SAMP>=20
  <DD>a NUL character (ASCII code 0)=20
  <DT><SAMP>`\123'</SAMP>=20
  <DD>the character with octal value 123=20
  <DT><SAMP>`\x2a'</SAMP>=20
  <DD>the character with hexadecimal value <CODE>2a</CODE>=20
  <DT><SAMP>`(<VAR>r</VAR>)'</SAMP>=20
  <DD>match an <VAR>r</VAR>; parentheses are used to override precedence =
(see=20
  below)=20
  <DT><SAMP>`<VAR>r</VAR><VAR>s</VAR>'</SAMP>=20
  <DD>the regular expression <VAR>r</VAR> followed by the regular =
expression=20
  <VAR>s</VAR>; called "concatenation"=20
  <DT><SAMP>`<VAR>r</VAR>|<VAR>s</VAR>'</SAMP>=20
  <DD>either an <VAR>r</VAR> or an <VAR>s</VAR>=20
  <DT><SAMP>`<VAR>r</VAR>/<VAR>s</VAR>'</SAMP>=20
  <DD>an <VAR>r</VAR> but only if it is followed by an <VAR>s</VAR>. The =
text=20
  matched by <VAR>s</VAR> is included when determining whether this rule =
is the=20
  <EM>longest match</EM>, but is then returned to the input before the =
action is=20
  executed. So the action only sees the text matched by <VAR>r</VAR>. =
This type=20
  of pattern is called <EM>trailing context</EM>. (There are some =
combinations=20
  of <SAMP>`<VAR>r</VAR>/<VAR>s</VAR>'</SAMP> that <CODE>flex</CODE> =
cannot=20
  match correctly; see notes in the Deficiencies / Bugs section below =
regarding=20
  "dangerous trailing context".)=20
  <DT><SAMP>`^<VAR>r</VAR>'</SAMP>=20
  <DD>an <VAR>r</VAR>, but only at the beginning of a line (i.e., which =
just=20
  starting to scan, or right after a newline has been scanned).=20
  <DT><SAMP>`<VAR>r</VAR>$'</SAMP>=20
  <DD>an <VAR>r</VAR>, but only at the end of a line (i.e., just before =
a=20
  newline). Equivalent to "<VAR>r</VAR>/\n". Note that flex's notion of=20
  "newline" is exactly whatever the C compiler used to compile flex =
interprets=20
  '\n' as; in particular, on some DOS systems you must either filter out =
\r's in=20
  the input yourself, or explicitly use <VAR>r</VAR>/\r\n for "r$".=20
  <DT><SAMP>`&lt;<VAR>s</VAR>&gt;<VAR>r</VAR>'</SAMP>=20
  <DD>an <VAR>r</VAR>, but only in start condition <VAR>s</VAR> (see =
below for=20
  discussion of start conditions)=20
  &lt;<VAR>s1</VAR>,<VAR>s2</VAR>,<VAR>s3</VAR>&gt;<VAR>r</VAR> same, =
but in any=20
  of start conditions <VAR>s1</VAR>, <VAR>s2</VAR>, or <VAR>s3</VAR>=20
  <DT><SAMP>`&lt;*&gt;<VAR>r</VAR>'</SAMP>=20
  <DD>an <VAR>r</VAR> in any start condition, even an exclusive one.=20
  <DT><SAMP>`&lt;&lt;EOF&gt;&gt;'</SAMP>=20
  <DD>an end-of-file=20
  =
<DT><SAMP>`&lt;<VAR>s1</VAR>,<VAR>s2</VAR>&gt;&lt;&lt;EOF&gt;&gt;'</SAMP>=
=20
  <DD>an end-of-file when in start condition <VAR>s1</VAR> or =
<VAR>s2</VAR>=20
</DD></DL>
<P>Note that inside of a character class, all regular expression =
operators lose=20
their special meaning except escape ('\') and the character class =
operators,=20
'-', ']', and, at the beginning of the class, '^'.=20
<P>The regular expressions listed above are grouped according to =
precedence,=20
from highest precedence at the top to lowest at the bottom. Those =
grouped=20
together have equal precedence. For example, <PRE>foo|bar*
</PRE>
<P>is the same as <PRE>(foo)|(ba(r*))
</PRE>
<P>since the '*' operator has higher precedence than concatenation, and=20
concatenation higher than alternation ('|'). This pattern therefore =
matches=20
<EM>either</EM> the string "foo" <EM>or</EM> the string "ba" followed by =

zero-or-more r's. To match "foo" or zero-or-more "bar"'s, use: =
<PRE>foo|(bar)*
</PRE>
<P>and to match zero-or-more "foo"'s-or-"bar"'s: <PRE>(foo|bar)*
</PRE>
<P>In addition to characters and ranges of characters, character classes =
can=20
also contain character class <EM>expressions</EM>. These are expressions =

enclosed inside <SAMP>`['</SAMP>: and <SAMP>`:'</SAMP>] delimiters =
(which=20
themselves must appear between the '[' and ']' of the character class; =
other=20
elements may occur inside the character class, too). The valid =
expressions are: <PRE>[:alnum:] [:alpha:] [:blank:]
[:cntrl:] [:digit:] [:graph:]
[:lower:] [:print:] [:punct:]
[:space:] [:upper:] [:xdigit:]
</PRE>
<P>These expressions all designate a set of characters equivalent to the =

corresponding standard C <SAMP>`isXXX'</SAMP> function. For example,=20
<SAMP>`[:alnum:]'</SAMP> designates those characters for which=20
<SAMP>`isalnum()'</SAMP> returns true - i.e., any alphabetic or numeric. =
Some=20
systems don't provide <SAMP>`isblank()'</SAMP>, so flex defines=20
<SAMP>`[:blank:]'</SAMP> as a blank or a tab.=20
<P>For example, the following character classes are all equivalent: =
<PRE>[[:alnum:]]
[[:alpha:][:digit:]
[[:alpha:]0-9]
[a-zA-Z0-9]
</PRE>
<P>If your scanner is case-insensitive (the <SAMP>`-i'</SAMP> flag), =
then=20
<SAMP>`[:upper:]'</SAMP> and <SAMP>`[:lower:]'</SAMP> are equivalent to=20
<SAMP>`[:alpha:]'</SAMP>.=20
<P>Some notes on patterns:=20
<UL>
  <LI>A negated character class such as the example "[^A-Z]" above =
<EM>will=20
  match a newline</EM> unless "\n" (or an equivalent escape sequence) is =
one of=20
  the characters explicitly present in the negated character class =
(e.g.,=20
  "[^A-Z\n]"). This is unlike how many other regular expression tools =
treat=20
  negated character classes, but unfortunately the inconsistency is =
historically=20
  entrenched. Matching newlines means that a pattern like [^"]* can =
match the=20
  entire input unless there's another quote in the input.=20
  <LI>A rule can have at most one instance of trailing context (the '/' =
operator=20
  or the '$' operator). The start condition, '^', and =
"&lt;&lt;EOF&gt;&gt;"=20
  patterns can only occur at the beginning of a pattern, and, as well as =
with=20
  '/' and '$', cannot be grouped inside parentheses. A '^' which does =
not occur=20
  at the beginning of a rule or a '$' which does not occur at the end of =
a rule=20
  loses its special properties and is treated as a normal character. The =

  following are illegal: <PRE>foo/bar$
&lt;sc1&gt;foo&lt;sc2&gt;bar
</PRE>Note that the first of these, can be written "foo/bar\n". The =
following=20
  will result in '$' or '^' being treated as a normal character: =
<PRE>foo|(bar$)
foo|^bar
</PRE>If what's wanted is a "foo" or a bar-followed-by-a-newline, the=20
  following could be used (the special '|' action is explained below): =
<PRE>foo      |
bar$     /* action goes here */
</PRE>A similar trick will work for matching a foo or a=20
  bar-at-the-beginning-of-a-line. </LI></UL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC8"=20
name=3DSEC8>How the input is matched</A></H2>
<P>When the generated scanner is run, it analyzes its input looking for =
strings=20
which match any of its patterns. If it finds more than one match, it =
takes the=20
one matching the most text (for trailing context rules, this includes =
the length=20
of the trailing part, even though it will then be returned to the =
input). If it=20
finds two or more matches of the same length, the rule listed first in =
the=20
<CODE>flex</CODE> input file is chosen.=20
<P>Once the match is determined, the text corresponding to the match =
(called the=20
<VAR>token</VAR>) is made available in the global character pointer=20
<CODE>yytext</CODE>, and its length in the global integer =
<CODE>yyleng</CODE>.=20
The <VAR>action</VAR> corresponding to the matched pattern is then =
executed (a=20
more detailed description of actions follows), and then the remaining =
input is=20
scanned for another match.=20
<P>If no match is found, then the <EM>default rule</EM> is executed: the =
next=20
character in the input is considered matched and copied to the standard =
output.=20
Thus, the simplest legal <CODE>flex</CODE> input is: <PRE>%%
</PRE>
<P>which generates a scanner that simply copies its input (one character =
at a=20
time) to its output.=20
<P>Note that <CODE>yytext</CODE> can be defined in two different ways: =
either as=20
a character <EM>pointer</EM> or as a character <EM>array</EM>. You can =
control=20
which definition <CODE>flex</CODE> uses by including one of the special=20
directives <SAMP>`%pointer'</SAMP> or <SAMP>`%array'</SAMP> in the first =

(definitions) section of your flex input. The default is=20
<SAMP>`%pointer'</SAMP>, unless you use the <SAMP>`-l'</SAMP> lex =
compatibility=20
option, in which case <CODE>yytext</CODE> will be an array. The =
advantage of=20
using <SAMP>`%pointer'</SAMP> is substantially faster scanning and no =
buffer=20
overflow when matching very large tokens (unless you run out of dynamic =
memory).=20
The disadvantage is that you are restricted in how your actions can =
modify=20
<CODE>yytext</CODE> (see the next section), and calls to the=20
<SAMP>`unput()'</SAMP> function destroys the present contents of=20
<CODE>yytext</CODE>, which can be a considerable porting headache when =
moving=20
between different <CODE>lex</CODE> versions.=20
<P>The advantage of <SAMP>`%array'</SAMP> is that you can then modify=20
<CODE>yytext</CODE> to your heart's content, and calls to =
<SAMP>`unput()'</SAMP>=20
do not destroy <CODE>yytext</CODE> (see below). Furthermore, existing=20
<CODE>lex</CODE> programs sometimes access <CODE>yytext</CODE> =
externally using=20
declarations of the form: <PRE>extern char yytext[];
</PRE>
<P>This definition is erroneous when used with <SAMP>`%pointer'</SAMP>, =
but=20
correct for <SAMP>`%array'</SAMP>.=20
<P><SAMP>`%array'</SAMP> defines <CODE>yytext</CODE> to be an array of=20
<CODE>YYLMAX</CODE> characters, which defaults to a fairly large value. =
You can=20
change the size by simply #define'ing <CODE>YYLMAX</CODE> to a different =
value=20
in the first section of your <CODE>flex</CODE> input. As mentioned =
above, with=20
<SAMP>`%pointer'</SAMP> yytext grows dynamically to accommodate large =
tokens.=20
While this means your <SAMP>`%pointer'</SAMP> scanner can accommodate =
very large=20
tokens (such as matching entire blocks of comments), bear in mind that =
each time=20
the scanner must resize <CODE>yytext</CODE> it also must rescan the =
entire token=20
from the beginning, so matching such tokens can prove slow. =
<CODE>yytext</CODE>=20
presently does <EM>not</EM> dynamically grow if a call to =
<SAMP>`unput()'</SAMP>=20
results in too much text being pushed back; instead, a run-time error =
results.=20
<P>Also note that you cannot use <SAMP>`%array'</SAMP> with C++ scanner =
classes=20
(the <CODE>c++</CODE> option; see below).=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC9"=20
name=3DSEC9>Actions</A></H2>
<P>Each pattern in a rule has a corresponding action, which can be any =
arbitrary=20
C statement. The pattern ends at the first non-escaped whitespace =
character; the=20
remainder of the line is its action. If the action is empty, then when =
the=20
pattern is matched the input token is simply discarded. For example, =
here is the=20
specification for a program which deletes all occurrences of "zap me" =
from its=20
input: <PRE>%%
"zap me"
</PRE>
<P>(It will copy all other characters in the input to the output since =
they will=20
be matched by the default rule.)=20
<P>Here is a program which compresses multiple blanks and tabs down to a =
single=20
blank, and throws away whitespace found at the end of a line: <PRE>%%
[ \t]+        putchar( ' ' );
[ \t]+$       /* ignore this token */
</PRE>
<P>If the action contains a '{', then the action spans till the =
balancing '}' is=20
found, and the action may cross multiple lines. <CODE>flex</CODE> knows =
about C=20
strings and comments and won't be fooled by braces found within them, =
but also=20
allows actions to begin with <SAMP>`%{'</SAMP> and will consider the =
action to=20
be all the text up to the next <SAMP>`%}'</SAMP> (regardless of ordinary =
braces=20
inside the action).=20
<P>An action consisting solely of a vertical bar ('|') means "same as =
the action=20
for the next rule." See below for an illustration.=20
<P>Actions can include arbitrary C code, including <CODE>return</CODE>=20
statements to return a value to whatever routine called =
<SAMP>`yylex()'</SAMP>.=20
Each time <SAMP>`yylex()'</SAMP> is called it continues processing =
tokens from=20
where it last left off until it either reaches the end of the file or =
executes a=20
return.=20
<P>Actions are free to modify <CODE>yytext</CODE> except for lengthening =
it=20
(adding characters to its end--these will overwrite later characters in =
the=20
input stream). This however does not apply when using =
<SAMP>`%array'</SAMP> (see=20
above); in that case, <CODE>yytext</CODE> may be freely modified in any =
way.=20
<P>Actions are free to modify <CODE>yyleng</CODE> except they should not =
do so=20
if the action also includes use of <SAMP>`yymore()'</SAMP> (see below).=20
<P>There are a number of special directives which can be included within =
an=20
action:=20
<UL>
  <LI><SAMP>`ECHO'</SAMP> copies yytext to the scanner's output.=20
  <LI><CODE>BEGIN</CODE> followed by the name of a start condition =
places the=20
  scanner in the corresponding start condition (see below).=20
  <LI><CODE>REJECT</CODE> directs the scanner to proceed on to the =
"second best"=20
  rule which matched the input (or a prefix of the input). The rule is =
chosen as=20
  described above in "How the Input is Matched", and <CODE>yytext</CODE> =
and=20
  <CODE>yyleng</CODE> set up appropriately. It may either be one which =
matched=20
  as much text as the originally chosen rule but came later in the=20
  <CODE>flex</CODE> input file, or one which matched less text. For =
example, the=20
  following will both count the words in the input and call the routine=20
  special() whenever "frob" is seen: <PRE>        int word_count =3D 0;
%%

frob        special(); REJECT;
[^ \t\n]+   ++word_count;
</PRE>Without the <CODE>REJECT</CODE>, any "frob"'s in the input would =
not be=20
  counted as words, since the scanner normally executes only one action =
per=20
  token. Multiple <CODE>REJECT's</CODE> are allowed, each one finding =
the next=20
  best choice to the currently active rule. For example, when the =
following=20
  scanner scans the token "abcd", it will write "abcdabcaba" to the =
output: <PRE>%%
a        |
ab       |
abc      |
abcd     ECHO; REJECT;
.|\n     /* eat up any unmatched character */
</PRE>(The first three rules share the fourth's action since they use =
the=20
  special '|' action.) <CODE>REJECT</CODE> is a particularly expensive =
feature=20
  in terms of scanner performance; if it is used in <EM>any</EM> of the=20
  scanner's actions it will slow down <EM>all</EM> of the scanner's =
matching.=20
  Furthermore, <CODE>REJECT</CODE> cannot be used with the =
<SAMP>`-Cf'</SAMP> or=20
  <SAMP>`-CF'</SAMP> options (see below). Note also that unlike the =
other=20
  special actions, <CODE>REJECT</CODE> is a <EM>branch</EM>; code =
immediately=20
  following it in the action will <EM>not</EM> be executed.=20
  <LI><SAMP>`yymore()'</SAMP> tells the scanner that the next time it =
matches a=20
  rule, the corresponding token should be <EM>appended</EM> onto the =
current=20
  value of <CODE>yytext</CODE> rather than replacing it. For example, =
given the=20
  input "mega-kludge" the following will write "mega-mega-kludge" to the =
output:=20
<PRE>%%
mega-    ECHO; yymore();
kludge   ECHO;
</PRE>First "mega-" is matched and echoed to the output. Then "kludge" =
is=20
  matched, but the previous "mega-" is still hanging around at the =
beginning of=20
  <CODE>yytext</CODE> so the <SAMP>`ECHO'</SAMP> for the "kludge" rule =
will=20
  actually write "mega-kludge". </LI></UL>
<P>Two notes regarding use of <SAMP>`yymore()'</SAMP>. First,=20
<SAMP>`yymore()'</SAMP> depends on the value of <CODE>yyleng</CODE> =
correctly=20
reflecting the size of the current token, so you must not modify=20
<CODE>yyleng</CODE> if you are using <SAMP>`yymore()'</SAMP>. Second, =
the=20
presence of <SAMP>`yymore()'</SAMP> in the scanner's action entails a =
minor=20
performance penalty in the scanner's matching speed.=20
<UL>
  <LI><SAMP>`yyless(n)'</SAMP> returns all but the first <VAR>n</VAR> =
characters=20
  of the current token back to the input stream, where they will be =
rescanned=20
  when the scanner looks for the next match. <CODE>yytext</CODE> and=20
  <CODE>yyleng</CODE> are adjusted appropriately (e.g., =
<CODE>yyleng</CODE> will=20
  now be equal to <VAR>n</VAR> ). For example, on the input "foobar" the =

  following will write out "foobarbar": <PRE>%%
foobar    ECHO; yyless(3);
[a-z]+    ECHO;
</PRE>An argument of 0 to <CODE>yyless</CODE> will cause the entire =
current=20
  input string to be scanned again. Unless you've changed how the =
scanner will=20
  subsequently process its input (using <CODE>BEGIN</CODE>, for =
example), this=20
  will result in an endless loop. Note that <CODE>yyless</CODE> is a =
macro and=20
  can only be used in the flex input file, not from other source files.=20
  <LI><SAMP>`unput(c)'</SAMP> puts the character <CODE>c</CODE> back =
onto the=20
  input stream. It will be the next character scanned. The following =
action will=20
  take the current token and cause it to be rescanned enclosed in =
parentheses. <PRE>{
int i;
/* Copy yytext because unput() trashes yytext */
char *yycopy =3D strdup( yytext );
unput( ')' );
for ( i =3D yyleng - 1; i &gt;=3D 0; --i )
    unput( yycopy[i] );
unput( '(' );
free( yycopy );
}
</PRE>Note that since each <SAMP>`unput()'</SAMP> puts the given =
character=20
  back at the <EM>beginning</EM> of the input stream, pushing back =
strings must=20
  be done back-to-front. An important potential problem when using=20
  <SAMP>`unput()'</SAMP> is that if you are using =
<SAMP>`%pointer'</SAMP> (the=20
  default), a call to <SAMP>`unput()'</SAMP> <EM>destroys</EM> the =
contents of=20
  <CODE>yytext</CODE>, starting with its rightmost character and =
devouring one=20
  character to the left with each call. If you need the value of yytext=20
  preserved after a call to <SAMP>`unput()'</SAMP> (as in the above =
example),=20
  you must either first copy it elsewhere, or build your scanner using=20
  <SAMP>`%array'</SAMP> instead (see How The Input Is Matched). Finally, =
note=20
  that you cannot put back <CODE>EOF</CODE> to attempt to mark the input =
stream=20
  with an end-of-file.=20
  <LI><SAMP>`input()'</SAMP> reads the next character from the input =
stream. For=20
  example, the following is one way to eat up C comments: <PRE>%%
"/*"        {
            register int c;

            for ( ; ; )
                {
                while ( (c =3D input()) !=3D '*' &amp;&amp;
                        c !=3D EOF )
                    ;    /* eat up text of comment */

                if ( c =3D=3D '*' )
                    {
                    while ( (c =3D input()) =3D=3D '*' )
                        ;
                    if ( c =3D=3D '/' )
                        break;    /* found the end */
                    }

                if ( c =3D=3D EOF )
                    {
                    error( "EOF in comment" );
                    break;
                    }
                }
            }
</PRE>(Note that if the scanner is compiled using <SAMP>`C++'</SAMP>, =
then=20
  <SAMP>`input()'</SAMP> is instead referred to as =
<SAMP>`yyinput()'</SAMP>, in=20
  order to avoid a name clash with the <SAMP>`C++'</SAMP> stream by the =
name of=20
  <CODE>input</CODE>.)=20
  <LI>YY_FLUSH_BUFFER flushes the scanner's internal buffer so that the =
next=20
  time the scanner attempts to match a token, it will first refill the =
buffer=20
  using <CODE>YY_INPUT</CODE> (see The Generated Scanner, below). This =
action is=20
  a special case of the more general <SAMP>`yy_flush_buffer()'</SAMP> =
function,=20
  described below in the section Multiple Input Buffers.=20
  <LI><SAMP>`yyterminate()'</SAMP> can be used in lieu of a return =
statement in=20
  an action. It terminates the scanner and returns a 0 to the scanner's =
caller,=20
  indicating "all done". By default, <SAMP>`yyterminate()'</SAMP> is =
also called=20
  when an end-of-file is encountered. It is a macro and may be =
redefined.=20
</LI></UL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC10"=20
name=3DSEC10>The generated scanner</A></H2>
<P>The output of <CODE>flex</CODE> is the file <TT>`lex.yy.c'</TT>, =
which=20
contains the scanning routine <SAMP>`yylex()'</SAMP>, a number of tables =
used by=20
it for matching tokens, and a number of auxiliary routines and macros. =
By=20
default, <SAMP>`yylex()'</SAMP> is declared as follows: <PRE>int yylex()
    {
    ... various definitions and the actions in here ...
    }
</PRE>
<P>(If your environment supports function prototypes, then it will be =
"int=20
yylex( void )".) This definition may be changed by defining the =
"YY_DECL" macro.=20
For example, you could use: <PRE>#define YY_DECL float lexscan( a, b ) =
float a, b;
</PRE>
<P>to give the scanning routine the name <CODE>lexscan</CODE>, returning =
a=20
float, and taking two floats as arguments. Note that if you give =
arguments to=20
the scanning routine using a K&amp;R-style/non-prototyped function =
declaration,=20
you must terminate the definition with a semi-colon (<SAMP>`;'</SAMP>).=20
<P>Whenever <SAMP>`yylex()'</SAMP> is called, it scans tokens from the =
global=20
input file <CODE>yyin</CODE> (which defaults to stdin). It continues =
until it=20
either reaches an end-of-file (at which point it returns the value 0) or =
one of=20
its actions executes a <CODE>return</CODE> statement.=20
<P>If the scanner reaches an end-of-file, subsequent calls are undefined =
unless=20
either <CODE>yyin</CODE> is pointed at a new input file (in which case =
scanning=20
continues from that file), or <SAMP>`yyrestart()'</SAMP> is called.=20
<SAMP>`yyrestart()'</SAMP> takes one argument, a <SAMP>`FILE *'</SAMP> =
pointer=20
(which can be nil, if you've set up <CODE>YY_INPUT</CODE> to scan from a =
source=20
other than <CODE>yyin</CODE>), and initializes <CODE>yyin</CODE> for =
scanning=20
from that file. Essentially there is no difference between just =
assigning=20
<CODE>yyin</CODE> to a new input file or using =
<SAMP>`yyrestart()'</SAMP> to do=20
so; the latter is available for compatibility with previous versions of=20
<CODE>flex</CODE>, and because it can be used to switch input files in =
the=20
middle of scanning. It can also be used to throw away the current input =
buffer,=20
by calling it with an argument of <CODE>yyin</CODE>; but better is to =
use=20
<CODE>YY_FLUSH_BUFFER</CODE> (see above). Note that =
<SAMP>`yyrestart()'</SAMP>=20
does <EM>not</EM> reset the start condition to <CODE>INITIAL</CODE> (see =
Start=20
Conditions, below).=20
<P>If <SAMP>`yylex()'</SAMP> stops scanning due to executing a=20
<CODE>return</CODE> statement in one of the actions, the scanner may =
then be=20
called again and it will resume scanning where it left off.=20
<P>By default (and for purposes of efficiency), the scanner uses =
block-reads=20
rather than simple <SAMP>`getc()'</SAMP> calls to read characters from=20
<CODE>yyin</CODE>. The nature of how it gets its input can be controlled =
by=20
defining the <CODE>YY_INPUT</CODE> macro. YY_INPUT's calling sequence is =

"YY_INPUT(buf,result,max_size)". Its action is to place up to=20
<VAR>max_size</VAR> characters in the character array <VAR>buf</VAR> and =
return=20
in the integer variable <VAR>result</VAR> either the number of =
characters read=20
or the constant YY_NULL (0 on Unix systems) to indicate EOF. The default =

YY_INPUT reads from the global file-pointer "yyin".=20
<P>A sample definition of YY_INPUT (in the definitions section of the =
input=20
file): <PRE>%{
#define YY_INPUT(buf,result,max_size) \
    { \
    int c =3D getchar(); \
    result =3D (c =3D=3D EOF) ? YY_NULL : (buf[0] =3D c, 1); \
    }
%}
</PRE>
<P>This definition will change the input processing to occur one =
character at a=20
time.=20
<P>When the scanner receives an end-of-file indication from YY_INPUT, it =
then=20
checks the <SAMP>`yywrap()'</SAMP> function. If <SAMP>`yywrap()'</SAMP> =
returns=20
false (zero), then it is assumed that the function has gone ahead and =
set up=20
<CODE>yyin</CODE> to point to another input file, and scanning =
continues. If it=20
returns true (non-zero), then the scanner terminates, returning 0 to its =
caller.=20
Note that in either case, the start condition remains unchanged; it does =

<EM>not</EM> revert to <CODE>INITIAL</CODE>.=20
<P>If you do not supply your own version of <SAMP>`yywrap()'</SAMP>, =
then you=20
must either use <SAMP>`%option noyywrap'</SAMP> (in which case the =
scanner=20
behaves as though <SAMP>`yywrap()'</SAMP> returned 1), or you must link =
with=20
<SAMP>`-lfl'</SAMP> to obtain the default version of the routine, which =
always=20
returns 1.=20
<P>Three routines are available for scanning from in-memory buffers =
rather than=20
files: <SAMP>`yy_scan_string()'</SAMP>, <SAMP>`yy_scan_bytes()'</SAMP>, =
and=20
<SAMP>`yy_scan_buffer()'</SAMP>. See the discussion of them below in the =
section=20
Multiple Input Buffers.=20
<P>The scanner writes its <SAMP>`ECHO'</SAMP> output to the =
<CODE>yyout</CODE>=20
global (default, stdout), which may be redefined by the user simply by =
assigning=20
it to some other <CODE>FILE</CODE> pointer.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC11"=20
name=3DSEC11>Start conditions</A></H2>
<P><CODE>flex</CODE> provides a mechanism for conditionally activating =
rules.=20
Any rule whose pattern is prefixed with "&lt;sc&gt;" will only be active =
when=20
the scanner is in the start condition named "sc". For example, =
<PRE>&lt;STRING&gt;[^"]*        { /* eat up the string body ... */
            ...
            }
</PRE>
<P>will be active only when the scanner is in the "STRING" start =
condition, and <PRE>&lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an =
escape ... */
            ...
            }
</PRE>
<P>will be active only when the current start condition is either =
"INITIAL",=20
"STRING", or "QUOTE".=20
<P>Start conditions are declared in the definitions (first) section of =
the input=20
using unindented lines beginning with either <SAMP>`%s'</SAMP> or=20
<SAMP>`%x'</SAMP> followed by a list of names. The former declares=20
<EM>inclusive</EM> start conditions, the latter <EM>exclusive</EM> start =

conditions. A start condition is activated using the <CODE>BEGIN</CODE> =
action.=20
Until the next <CODE>BEGIN</CODE> action is executed, rules with the =
given start=20
condition will be active and rules with other start conditions will be =
inactive.=20
If the start condition is <EM>inclusive</EM>, then rules with no start=20
conditions at all will also be active. If it is <EM>exclusive</EM>, then =

<EM>only</EM> rules qualified with the start condition will be active. A =
set of=20
rules contingent on the same exclusive start condition describe a =
scanner which=20
is independent of any of the other rules in the <CODE>flex</CODE> input. =
Because=20
of this, exclusive start conditions make it easy to specify =
"mini-scanners"=20
which scan portions of the input that are syntactically different from =
the rest=20
(e.g., comments).=20
<P>If the distinction between inclusive and exclusive start conditions =
is still=20
a little vague, here's a simple example illustrating the connection =
between the=20
two. The set of rules: <PRE>%s example
%%

&lt;example&gt;foo   do_something();

bar            something_else();
</PRE>
<P>is equivalent to <PRE>%x example
%%

&lt;example&gt;foo   do_something();

&lt;INITIAL,example&gt;bar    something_else();
</PRE>
<P>Without the <SAMP>`&lt;INITIAL,example&gt;'</SAMP> qualifier, the=20
<SAMP>`bar'</SAMP> pattern in the second example wouldn't be active =
(i.e.,=20
couldn't match) when in start condition <SAMP>`example'</SAMP>. If we =
just used=20
<SAMP>`&lt;example&gt;'</SAMP> to qualify <SAMP>`bar'</SAMP>, though, =
then it=20
would only be active in <SAMP>`example'</SAMP> and not in =
<CODE>INITIAL</CODE>,=20
while in the first example it's active in both, because in the first =
example the=20
<SAMP>`example'</SAMP> starting condition is an <EM>inclusive</EM>=20
(<SAMP>`%s'</SAMP>) start condition.=20
<P>Also note that the special start-condition specifier =
<SAMP>`&lt;*&gt;'</SAMP>=20
matches every start condition. Thus, the above example could also have =
been=20
written; <PRE>%x example
%%

&lt;example&gt;foo   do_something();

&lt;*&gt;bar    something_else();
</PRE>
<P>The default rule (to <SAMP>`ECHO'</SAMP> any unmatched character) =
remains=20
active in start conditions. It is equivalent to: <PRE>&lt;*&gt;.|\\n     =
ECHO;
</PRE>
<P><SAMP>`BEGIN(0)'</SAMP> returns to the original state where only the =
rules=20
with no start conditions are active. This state can also be referred to =
as the=20
start-condition "INITIAL", so <SAMP>`BEGIN(INITIAL)'</SAMP> is =
equivalent to=20
<SAMP>`BEGIN(0)'</SAMP>. (The parentheses around the start condition =
name are=20
not required but are considered good style.)=20
<P><CODE>BEGIN</CODE> actions can also be given as indented code at the=20
beginning of the rules section. For example, the following will cause =
the=20
scanner to enter the "SPECIAL" start condition whenever =
<SAMP>`yylex()'</SAMP>=20
is called and the global variable <CODE>enter_special</CODE> is true: =
<PRE>        int enter_special;

%x SPECIAL
%%
        if ( enter_special )
            BEGIN(SPECIAL);

&lt;SPECIAL&gt;blahblahblah
...more rules follow...
</PRE>
<P>To illustrate the uses of start conditions, here is a scanner which =
provides=20
two different interpretations of a string like "123.456". By default it =
will=20
treat it as as three tokens, the integer "123", a dot ('.'), and the =
integer=20
"456". But if the string is preceded earlier in the line by the string=20
"expect-floats" it will treat it as a single token, the floating-point =
number=20
123.456: <PRE>%{
#include &lt;math.h&gt;
%}
%s expect

%%
expect-floats        BEGIN(expect);

&lt;expect&gt;[0-9]+"."[0-9]+      {
            printf( "found a float, =3D %f\n",
                    atof( yytext ) );
            }
&lt;expect&gt;\n           {
            /* that's the end of the line, so
             * we need another "expect-number"
             * before we'll recognize any more
             * numbers
             */
            BEGIN(INITIAL);
            }

[0-9]+      {

Version 2.5               December 1994                        18

            printf( "found an integer, =3D %d\n",
                    atoi( yytext ) );
            }

"."         printf( "found a dot\n" );
</PRE>
<P>Here is a scanner which recognizes (and discards) C comments while=20
maintaining a count of the current input line. <PRE>%x comment
%%
        int line_num =3D 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
&lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</PRE>
<P>This scanner goes to a bit of trouble to match as much text as =
possible with=20
each rule. In general, when attempting to write a high-speed scanner try =
to=20
match as much possible in each rule, as it's a big win.=20
<P>Note that start-conditions names are really integer values and can be =
stored=20
as such. Thus, the above could be extended in the following fashion: =
<PRE>%x comment foo
%%
        int line_num =3D 1;
        int comment_caller;

"/*"         {
             comment_caller =3D INITIAL;
             BEGIN(comment);
             }

...

&lt;foo&gt;"/*"    {
             comment_caller =3D foo;
             BEGIN(comment);
             }

&lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
&lt;comment&gt;"*"+[^*/\n]*   /* eat up '*'s not followed by '/'s */
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(comment_caller);
</PRE>
<P>Furthermore, you can access the current start condition using the=20
integer-valued <CODE>YY_START</CODE> macro. For example, the above =
assignments=20
to <CODE>comment_caller</CODE> could instead be written =
<PRE>comment_caller =3D YY_START;
</PRE>
<P>Flex provides <CODE>YYSTATE</CODE> as an alias for =
<CODE>YY_START</CODE>=20
(since that is what's used by AT&amp;T <CODE>lex</CODE>).=20
<P>Note that start conditions do not have their own name-space; %s's and =
%x's=20
declare names in the same fashion as #define's.=20
<P>Finally, here's an example of how to match C-style quoted strings =
using=20
exclusive start conditions, including expanded escape sequences (but not =

including checking for a string that's too long): <PRE>%x str

%%
        char string_buf[MAX_STR_CONST];
        char *string_buf_ptr;

\"      string_buf_ptr =3D string_buf; BEGIN(str);

&lt;str&gt;\"        { /* saw closing quote - all done */
        BEGIN(INITIAL);
        *string_buf_ptr =3D '\0';
        /* return string constant token type and
         * value to parser
         */
        }

&lt;str&gt;\n        {
        /* error - unterminated string constant */
        /* generate error message */
        }

&lt;str&gt;\\[0-7]{1,3} {
        /* octal escape sequence */
        int result;

        (void) sscanf( yytext + 1, "%o", &amp;result );

        if ( result &gt; 0xff )
                /* error, constant is out-of-bounds */

        *string_buf_ptr++ =3D result;
        }

&lt;str&gt;\\[0-9]+ {
        /* generate error - bad escape sequence; something
         * like '\48' or '\0777777'
         */
        }

&lt;str&gt;\\n  *string_buf_ptr++ =3D '\n';
&lt;str&gt;\\t  *string_buf_ptr++ =3D '\t';
&lt;str&gt;\\r  *string_buf_ptr++ =3D '\r';
&lt;str&gt;\\b  *string_buf_ptr++ =3D '\b';
&lt;str&gt;\\f  *string_buf_ptr++ =3D '\f';

&lt;str&gt;\\(.|\n)  *string_buf_ptr++ =3D yytext[1];

&lt;str&gt;[^\\\n\"]+        {
        char *yptr =3D yytext;

        while ( *yptr )
                *string_buf_ptr++ =3D *yptr++;
        }
</PRE>
<P>Often, such as in some of the examples above, you wind up writing a =
whole=20
bunch of rules all preceded by the same start condition(s). Flex makes =
this a=20
little easier and cleaner by introducing a notion of start condition=20
<EM>scope</EM>. A start condition scope is begun with: <PRE>&lt;SCs&gt;{
</PRE>
<P>where SCs is a list of one or more start conditions. Inside the start =

condition scope, every rule automatically has the prefix=20
<SAMP>`&lt;SCs&gt;'</SAMP> applied to it, until a <SAMP>`}'</SAMP> which =
matches=20
the initial <SAMP>`{'</SAMP>. So, for example, <PRE>&lt;ESC&gt;{
    "\\n"   return '\n';
    "\\r"   return '\r';
    "\\f"   return '\f';
    "\\0"   return '\0';
}
</PRE>
<P>is equivalent to: <PRE>&lt;ESC&gt;"\\n"  return '\n';
&lt;ESC&gt;"\\r"  return '\r';
&lt;ESC&gt;"\\f"  return '\f';
&lt;ESC&gt;"\\0"  return '\0';
</PRE>
<P>Start condition scopes may be nested.=20
<P>Three routines are available for manipulating stacks of start =
conditions:=20
<DL compact>
  <DT><SAMP>`void yy_push_state(int new_state)'</SAMP>=20
  <DD>pushes the current start condition onto the top of the start =
condition=20
  stack and switches to <VAR>new_state</VAR> as though you had used =
<SAMP>`BEGIN=20
  new_state'</SAMP> (recall that start condition names are also =
integers).=20
  <DT><SAMP>`void yy_pop_state()'</SAMP>=20
  <DD>pops the top of the stack and switches to it via =
<CODE>BEGIN</CODE>.=20
  <DT><SAMP>`int yy_top_state()'</SAMP>=20
  <DD>returns the top of the stack without altering the stack's =
contents.=20
</DD></DL>
<P>The start condition stack grows dynamically and so has no built-in =
size=20
limitation. If memory is exhausted, program execution aborts.=20
<P>To use start condition stacks, your scanner must include a =
<SAMP>`%option=20
stack'</SAMP> directive (see Options below).=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC12"=20
name=3DSEC12>Multiple input buffers</A></H2>
<P>Some scanners (such as those which support "include" files) require =
reading=20
from several input streams. As <CODE>flex</CODE> scanners do a large =
amount of=20
buffering, one cannot control where the next input will be read from by =
simply=20
writing a <CODE>YY_INPUT</CODE> which is sensitive to the scanning =
context.=20
<CODE>YY_INPUT</CODE> is only called when the scanner reaches the end of =
its=20
buffer, which may be a long time after scanning a statement such as an =
"include"=20
which requires switching the input source.=20
<P>To negotiate these sorts of problems, <CODE>flex</CODE> provides a =
mechanism=20
for creating and switching between multiple input buffers. An input =
buffer is=20
created by using: <PRE>YY_BUFFER_STATE yy_create_buffer( FILE *file, int =
size )
</PRE>
<P>which takes a <CODE>FILE</CODE> pointer and a size and creates a =
buffer=20
associated with the given file and large enough to hold <VAR>size</VAR>=20
characters (when in doubt, use <CODE>YY_BUF_SIZE</CODE> for the size). =
It=20
returns a <CODE>YY_BUFFER_STATE</CODE> handle, which may then be passed =
to other=20
routines (see below). The <CODE>YY_BUFFER_STATE</CODE> type is a pointer =
to an=20
opaque <CODE>struct</CODE> <CODE>yy_buffer_state</CODE> structure, so =
you may=20
safely initialize YY_BUFFER_STATE variables to <SAMP>`((YY_BUFFER_STATE) =

0)'</SAMP> if you wish, and also refer to the opaque structure in order =
to=20
correctly declare input buffers in source files other than that of your =
scanner.=20
Note that the <CODE>FILE</CODE> pointer in the call to=20
<CODE>yy_create_buffer</CODE> is only used as the value of =
<CODE>yyin</CODE>=20
seen by <CODE>YY_INPUT</CODE>; if you redefine <CODE>YY_INPUT</CODE> so =
it no=20
longer uses <CODE>yyin</CODE>, then you can safely pass a nil =
<CODE>FILE</CODE>=20
pointer to <CODE>yy_create_buffer</CODE>. You select a particular buffer =
to scan=20
from using: <PRE>void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
</PRE>
<P>switches the scanner's input buffer so subsequent tokens will come =
from=20
<VAR>new_buffer</VAR>. Note that <SAMP>`yy_switch_to_buffer()'</SAMP> =
may be=20
used by <SAMP>`yywrap()'</SAMP> to set things up for continued scanning, =
instead=20
of opening a new file and pointing <CODE>yyin</CODE> at it. Note also =
that=20
switching input sources via either <SAMP>`yy_switch_to_buffer()'</SAMP> =
or=20
<SAMP>`yywrap()'</SAMP> does <EM>not</EM> change the start condition. =
<PRE>void yy_delete_buffer( YY_BUFFER_STATE buffer )
</PRE>
<P>is used to reclaim the storage associated with a buffer. You can also =
clear=20
the current contents of a buffer using: <PRE>void yy_flush_buffer( =
YY_BUFFER_STATE buffer )
</PRE>
<P>This function discards the buffer's contents, so the next time the =
scanner=20
attempts to match a token from the buffer, it will first fill the buffer =
anew=20
using <CODE>YY_INPUT</CODE>.=20
<P><SAMP>`yy_new_buffer()'</SAMP> is an alias for=20
<SAMP>`yy_create_buffer()'</SAMP>, provided for compatibility with the =
C++ use=20
of <CODE>new</CODE> and <CODE>delete</CODE> for creating and destroying =
dynamic=20
objects.=20
<P>Finally, the <CODE>YY_CURRENT_BUFFER</CODE> macro returns a=20
<CODE>YY_BUFFER_STATE</CODE> handle to the current buffer.=20
<P>Here is an example of using these features for writing a scanner =
which=20
expands include files (the <SAMP>`&lt;&lt;EOF&gt;&gt;'</SAMP> feature is =

discussed below): <PRE>/* the "incl" state is used for picking up the =
name
 * of an include file
 */
%x incl

%{
#define MAX_INCLUDE_DEPTH 10
YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
int include_stack_ptr =3D 0;
%}

%%
include             BEGIN(incl);

[a-z]+              ECHO;
[^a-z\n]*\n?        ECHO;

&lt;incl&gt;[ \t]*      /* eat the whitespace */
&lt;incl&gt;[^ \t\n]+   { /* got the include file name */
        if ( include_stack_ptr &gt;=3D MAX_INCLUDE_DEPTH )
            {
            fprintf( stderr, "Includes nested too deeply" );
            exit( 1 );
            }

        include_stack[include_stack_ptr++] =3D
            YY_CURRENT_BUFFER;

        yyin =3D fopen( yytext, "r" );

        if ( ! yyin )
            error( ... );

        yy_switch_to_buffer(
            yy_create_buffer( yyin, YY_BUF_SIZE ) );

        BEGIN(INITIAL);
        }

&lt;&lt;EOF&gt;&gt; {
        if ( --include_stack_ptr &lt; 0 )
            {
            yyterminate();
            }

        else
            {
            yy_delete_buffer( YY_CURRENT_BUFFER );
            yy_switch_to_buffer(
                 include_stack[include_stack_ptr] );
            }
        }
</PRE>
<P>Three routines are available for setting up input buffers for =
scanning=20
in-memory strings instead of files. All of them create a new input =
buffer for=20
scanning the string, and return a corresponding =
<CODE>YY_BUFFER_STATE</CODE>=20
handle (which you should delete with <SAMP>`yy_delete_buffer()'</SAMP> =
when done=20
with it). They also switch to the new buffer using=20
<SAMP>`yy_switch_to_buffer()'</SAMP>, so the next call to =
<SAMP>`yylex()'</SAMP>=20
will start scanning the string.=20
<DL compact>
  <DT><SAMP>`yy_scan_string(const char *str)'</SAMP>=20
  <DD>scans a NUL-terminated string.=20
  <DT><SAMP>`yy_scan_bytes(const char *bytes, int len)'</SAMP>=20
  <DD>scans <CODE>len</CODE> bytes (including possibly NUL's) starting =
at=20
  location <VAR>bytes</VAR>. </DD></DL>
<P>Note that both of these functions create and scan a <EM>copy</EM> of =
the=20
string or bytes. (This may be desirable, since <SAMP>`yylex()'</SAMP> =
modifies=20
the contents of the buffer it is scanning.) You can avoid the copy by =
using:=20
<DL compact>
  <DT><SAMP>`yy_scan_buffer(char *base, yy_size_t size)'</SAMP>=20
  <DD>which scans in place the buffer starting at <VAR>base</VAR>, =
consisting of=20
  <VAR>size</VAR> bytes, the last two bytes of which <EM>must</EM> be=20
  <CODE>YY_END_OF_BUFFER_CHAR</CODE> (ASCII NUL). These last two bytes =
are not=20
  scanned; thus, scanning consists of <SAMP>`base[0]'</SAMP> through=20
  <SAMP>`base[size-2]'</SAMP>, inclusive. If you fail to set up =
<VAR>base</VAR>=20
  in this manner (i.e., forget the final two =
<CODE>YY_END_OF_BUFFER_CHAR</CODE>=20
  bytes), then <SAMP>`yy_scan_buffer()'</SAMP> returns a nil pointer =
instead of=20
  creating a new input buffer. The type <CODE>yy_size_t</CODE> is an =
integral=20
  type to which you can cast an integer expression reflecting the size =
of the=20
  buffer. </DD></DL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC13"=20
name=3DSEC13>End-of-file rules</A></H2>
<P>The special rule "&lt;&lt;EOF&gt;&gt;" indicates actions which are to =
be=20
taken when an end-of-file is encountered and yywrap() returns non-zero =
(i.e.,=20
indicates no further files to process). The action must finish by doing =
one of=20
four things:=20
<UL>
  <LI>assigning <CODE>yyin</CODE> to a new input file (in previous =
versions of=20
  flex, after doing the assignment you had to call the special action=20
  <CODE>YY_NEW_FILE</CODE>; this is no longer necessary);=20
  <LI>executing a <CODE>return</CODE> statement;=20
  <LI>executing the special <SAMP>`yyterminate()'</SAMP> action;=20
  <LI>or, switching to a new buffer using =
<SAMP>`yy_switch_to_buffer()'</SAMP>=20
  as shown in the example above. </LI></UL>
<P>&lt;&lt;EOF&gt;&gt; rules may not be used with other patterns; they =
may only=20
be qualified with a list of start conditions. If an unqualified=20
&lt;&lt;EOF&gt;&gt; rule is given, it applies to <EM>all</EM> start =
conditions=20
which do not already have &lt;&lt;EOF&gt;&gt; actions. To specify an=20
&lt;&lt;EOF&gt;&gt; rule for only the initial start condition, use =
<PRE>&lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;
</PRE>
<P>These rules are useful for catching things like unclosed comments. An =

example: <PRE>%x quote
%%

...other rules for dealing with quotes...

&lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
         error( "unterminated quote" );
         yyterminate();
         }
&lt;&lt;EOF&gt;&gt;  {
         if ( *++filelist )
             yyin =3D fopen( *filelist, "r" );
         else
            yyterminate();
         }
</PRE>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC14"=20
name=3DSEC14>Miscellaneous macros</A></H2>
<P>The macro <CODE>YY_USER_ACTION</CODE> can be defined to provide an =
action=20
which is always executed prior to the matched rule's action. For =
example, it=20
could be #define'd to call a routine to convert yytext to lower-case. =
When=20
<CODE>YY_USER_ACTION</CODE> is invoked, the variable <CODE>yy_act</CODE> =
gives=20
the number of the matched rule (rules are numbered starting with 1). =
Suppose you=20
want to profile how often each of your rules is matched. The following =
would do=20
the trick: <PRE>#define YY_USER_ACTION ++ctr[yy_act]
</PRE>
<P>where <CODE>ctr</CODE> is an array to hold the counts for the =
different=20
rules. Note that the macro <CODE>YY_NUM_RULES</CODE> gives the total =
number of=20
rules (including the default rule, even if you use <SAMP>`-s'</SAMP>, so =
a=20
correct declaration for <CODE>ctr</CODE> is: <PRE>int ctr[YY_NUM_RULES];
</PRE>
<P>The macro <CODE>YY_USER_INIT</CODE> may be defined to provide an =
action which=20
is always executed before the first scan (and before the scanner's =
internal=20
initializations are done). For example, it could be used to call a =
routine to=20
read in a data table or open a logging file.=20
<P>The macro <SAMP>`yy_set_interactive(is_interactive)'</SAMP> can be =
used to=20
control whether the current buffer is considered <EM>interactive</EM>. =
An=20
interactive buffer is processed more slowly, but must be used when the =
scanner's=20
input source is indeed interactive to avoid problems due to waiting to =
fill=20
buffers (see the discussion of the <SAMP>`-I'</SAMP> flag below). A =
non-zero=20
value in the macro invocation marks the buffer as interactive, a zero =
value as=20
non-interactive. Note that use of this macro overrides <SAMP>`%option=20
always-interactive'</SAMP> or <SAMP>`%option never-interactive'</SAMP> =
(see=20
Options below). <SAMP>`yy_set_interactive()'</SAMP> must be invoked =
prior to=20
beginning to scan the buffer that is (or is not) to be considered =
interactive.=20
<P>The macro <SAMP>`yy_set_bol(at_bol)'</SAMP> can be used to control =
whether=20
the current buffer's scanning context for the next token match is done =
as though=20
at the beginning of a line. A non-zero macro argument makes rules =
anchored with=20
<P>The macro <SAMP>`YY_AT_BOL()'</SAMP> returns true if the next token =
scanned=20
from the current buffer will have '^' rules active, false otherwise.=20
<P>In the generated scanner, the actions are all gathered in one large =
switch=20
statement and separated using <CODE>YY_BREAK</CODE>, which may be =
redefined. By=20
default, it is simply a "break", to separate each rule's action from the =

following rule's. Redefining <CODE>YY_BREAK</CODE> allows, for example, =
C++=20
users to #define YY_BREAK to do nothing (while being very careful that =
every=20
rule ends with a "break" or a "return"!) to avoid suffering from =
unreachable=20
statement warnings where because a rule's action ends with "return", the =

<CODE>YY_BREAK</CODE> is inaccessible.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC15"=20
name=3DSEC15>Values available to the user</A></H2>
<P>This section summarizes the various values available to the user in =
the rule=20
actions.=20
<UL>
  <LI><SAMP>`char *yytext'</SAMP> holds the text of the current token. =
It may be=20
  modified but not lengthened (you cannot append characters to the end). =
If the=20
  special directive <SAMP>`%array'</SAMP> appears in the first section =
of the=20
  scanner description, then <CODE>yytext</CODE> is instead declared =
<SAMP>`char=20
  yytext[YYLMAX]'</SAMP>, where <CODE>YYLMAX</CODE> is a macro =
definition that=20
  you can redefine in the first section if you don't like the default =
value=20
  (generally 8KB). Using <SAMP>`%array'</SAMP> results in somewhat =
slower=20
  scanners, but the value of <CODE>yytext</CODE> becomes immune to calls =
to=20
  <SAMP>`input()'</SAMP> and <SAMP>`unput()'</SAMP>, which potentially =
destroy=20
  its value when <CODE>yytext</CODE> is a character pointer. The =
opposite of=20
  <SAMP>`%array'</SAMP> is <SAMP>`%pointer'</SAMP>, which is the =
default. You=20
  cannot use <SAMP>`%array'</SAMP> when generating C++ scanner classes =
(the=20
  <SAMP>`-+'</SAMP> flag).=20
  <LI><SAMP>`int yyleng'</SAMP> holds the length of the current token.=20
  <LI><SAMP>`FILE *yyin'</SAMP> is the file which by default =
<CODE>flex</CODE>=20
  reads from. It may be redefined but doing so only makes sense before =
scanning=20
  begins or after an EOF has been encountered. Changing it in the midst =
of=20
  scanning will have unexpected results since <CODE>flex</CODE> buffers =
its=20
  input; use <SAMP>`yyrestart()'</SAMP> instead. Once scanning =
terminates=20
  because an end-of-file has been seen, you can assign <CODE>yyin</CODE> =
at the=20
  new input file and then call the scanner again to continue scanning.=20
  <LI><SAMP>`void yyrestart( FILE *new_file )'</SAMP> may be called to =
point=20
  <CODE>yyin</CODE> at the new input file. The switch-over to the new =
file is=20
  immediate (any previously buffered-up input is lost). Note that =
calling=20
  <SAMP>`yyrestart()'</SAMP> with <CODE>yyin</CODE> as an argument thus =
throws=20
  away the current input buffer and continues scanning the same input =
file.=20
  <LI><SAMP>`FILE *yyout'</SAMP> is the file to which =
<SAMP>`ECHO'</SAMP>=20
  actions are done. It can be reassigned by the user.=20
  <LI><CODE>YY_CURRENT_BUFFER</CODE> returns a =
<CODE>YY_BUFFER_STATE</CODE>=20
  handle to the current buffer.=20
  <LI><CODE>YY_START</CODE> returns an integer value corresponding to =
the=20
  current start condition. You can subsequently use this value with=20
  <CODE>BEGIN</CODE> to return to that start condition. </LI></UL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC16"=20
name=3DSEC16>Interfacing with <CODE>yacc</CODE></A></H2>
<P>One of the main uses of <CODE>flex</CODE> is as a companion to the=20
<CODE>yacc</CODE> parser-generator. <CODE>yacc</CODE> parsers expect to =
call a=20
routine named <SAMP>`yylex()'</SAMP> to find the next input token. The =
routine=20
is supposed to return the type of the next token as well as putting any=20
associated value in the global <CODE>yylval</CODE>. To use =
<CODE>flex</CODE>=20
with <CODE>yacc</CODE>, one specifies the <SAMP>`-d'</SAMP> option to=20
<CODE>yacc</CODE> to instruct it to generate the file <TT>`y.tab.h'</TT> =

containing definitions of all the <SAMP>`%tokens'</SAMP> appearing in =
the=20
<CODE>yacc</CODE> input. This file is then included in the =
<CODE>flex</CODE>=20
scanner. For example, if one of the tokens is "TOK_NUMBER", part of the =
scanner=20
might look like: <PRE>%{
#include "y.tab.h"
%}

%%

[0-9]+        yylval =3D atoi( yytext ); return TOK_NUMBER;
</PRE>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC17"=20
name=3DSEC17>Options</A></H2>
<P><CODE>flex</CODE> has the following options:=20
<DL compact>
  <DT><SAMP>`-b'</SAMP>=20
  <DD>Generate backing-up information to <TT>`lex.backup'</TT>. This is =
a list=20
  of scanner states which require backing up and the input characters on =
which=20
  they do so. By adding rules one can remove backing-up states. If =
<EM>all</EM>=20
  backing-up states are eliminated and <SAMP>`-Cf'</SAMP> or =
<SAMP>`-CF'</SAMP>=20
  is used, the generated scanner will run faster (see the =
<SAMP>`-p'</SAMP>=20
  flag). Only users who wish to squeeze every last cycle out of their =
scanners=20
  need worry about this option. (See the section on Performance =
Considerations=20
  below.)=20
  <DT><SAMP>`-c'</SAMP>=20
  <DD>is a do-nothing, deprecated option included for POSIX compliance.=20
  <DT><SAMP>`-d'</SAMP>=20
  <DD>makes the generated scanner run in <EM>debug</EM> mode. Whenever a =
pattern=20
  is recognized and the global <CODE>yy_flex_debug</CODE> is non-zero =
(which is=20
  the default), the scanner will write to <CODE>stderr</CODE> a line of =
the=20
  form: <PRE>--accepting rule at line 53 ("the matched text")
</PRE>The line number refers to the location of the rule in the file =
defining=20
  the scanner (i.e., the file that was fed to flex). Messages are also =
generated=20
  when the scanner backs up, accepts the default rule, reaches the end =
of its=20
  input buffer (or encounters a NUL; at this point, the two look the =
same as far=20
  as the scanner's concerned), or reaches an end-of-file.=20
  <DT><SAMP>`-f'</SAMP>=20
  <DD>specifies <EM>fast scanner</EM>. No table compression is done and =
stdio is=20
  bypassed. The result is large but fast. This option is equivalent to=20
  <SAMP>`-Cfr'</SAMP> (see below).=20
  <DT><SAMP>`-h'</SAMP>=20
  <DD>generates a "help" summary of <CODE>flex's</CODE> options to=20
  <CODE>stdout</CODE> and then exits. <SAMP>`-?'</SAMP> and=20
  <SAMP>`--help'</SAMP> are synonyms for <SAMP>`-h'</SAMP>.=20
  <DT><SAMP>`-i'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> to generate a =
<EM>case-insensitive</EM>=20
  scanner. The case of letters given in the <CODE>flex</CODE> input =
patterns=20
  will be ignored, and tokens in the input will be matched regardless of =
case.=20
  The matched text given in <CODE>yytext</CODE> will have the preserved =
case=20
  (i.e., it will not be folded).=20
  <DT><SAMP>`-l'</SAMP>=20
  <DD>turns on maximum compatibility with the original AT&amp;T =
<CODE>lex</CODE>=20
  implementation. Note that this does not mean <EM>full</EM> =
compatibility. Use=20
  of this option costs a considerable amount of performance, and it =
cannot be=20
  used with the <SAMP>`-+, -f, -F, -Cf'</SAMP>, or <SAMP>`-CF'</SAMP> =
options.=20
  For details on the compatibilities it provides, see the section=20
  "Incompatibilities With Lex And POSIX" below. This option also results =
in the=20
  name <CODE>YY_FLEX_LEX_COMPAT</CODE> being #define'd in the generated =
scanner.=20

  <DT><SAMP>`-n'</SAMP>=20
  <DD>is another do-nothing, deprecated option included only for POSIX=20
  compliance.=20
  <DT><SAMP>`-p'</SAMP>=20
  <DD>generates a performance report to stderr. The report consists of =
comments=20
  regarding features of the <CODE>flex</CODE> input file which will =
cause a=20
  serious loss of performance in the resulting scanner. If you give the =
flag=20
  twice, you will also get comments regarding features that lead to =
minor=20
  performance losses. Note that the use of <CODE>REJECT</CODE>, =
<SAMP>`%option=20
  yylineno'</SAMP> and variable trailing context (see the Deficiencies / =
Bugs=20
  section below) entails a substantial performance penalty; use of=20
  <SAMP>`yymore()'</SAMP>, the <SAMP>`^'</SAMP> operator, and the=20
  <SAMP>`-I'</SAMP> flag entail minor performance penalties.=20
  <DT><SAMP>`-s'</SAMP>=20
  <DD>causes the <EM>default rule</EM> (that unmatched scanner input is =
echoed=20
  to <CODE>stdout</CODE>) to be suppressed. If the scanner encounters =
input that=20
  does not match any of its rules, it aborts with an error. This option =
is=20
  useful for finding holes in a scanner's rule set.=20
  <DT><SAMP>`-t'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> to write the scanner it generates to =
standard=20
  output instead of <TT>`lex.yy.c'</TT>.=20
  <DT><SAMP>`-v'</SAMP>=20
  <DD>specifies that <CODE>flex</CODE> should write to =
<CODE>stderr</CODE> a=20
  summary of statistics regarding the scanner it generates. Most of the=20
  statistics are meaningless to the casual <CODE>flex</CODE> user, but =
the first=20
  line identifies the version of <CODE>flex</CODE> (same as reported by=20
  <SAMP>`-V'</SAMP>), and the next line the flags used when generating =
the=20
  scanner, including those that are on by default.=20
  <DT><SAMP>`-w'</SAMP>=20
  <DD>suppresses warning messages.=20
  <DT><SAMP>`-B'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> to generate a <EM>batch</EM> scanner, =
the=20
  opposite of <EM>interactive</EM> scanners generated by =
<SAMP>`-I'</SAMP> (see=20
  below). In general, you use <SAMP>`-B'</SAMP> when you are =
<EM>certain</EM>=20
  that your scanner will never be used interactively, and you want to =
squeeze a=20
  <EM>little</EM> more performance out of it. If your goal is instead to =
squeeze=20
  out a <EM>lot</EM> more performance, you should be using the=20
  <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> options (discussed below), =
which turn=20
  on <SAMP>`-B'</SAMP> automatically anyway.=20
  <DT><SAMP>`-F'</SAMP>=20
  <DD>specifies that the <EM>fast</EM> scanner table representation =
should be=20
  used (and stdio bypassed). This representation is about as fast as the =
full=20
  table representation <SAMP>`(-f)'</SAMP>, and for some sets of =
patterns will=20
  be considerably smaller (and for others, larger). In general, if the =
pattern=20
  set contains both "keywords" and a catch-all, "identifier" rule, such =
as in=20
  the set: <PRE>"case"    return TOK_CASE;
"switch"  return TOK_SWITCH;
...
"default" return TOK_DEFAULT;
[a-z]+    return TOK_ID;
</PRE>then you're better off using the full table representation. If =
only the=20
  "identifier" rule is present and you then use a hash table or some =
such to=20
  detect the keywords, you're better off using <SAMP>`-F'</SAMP>. This =
option is=20
  equivalent to <SAMP>`-CFr'</SAMP> (see below). It cannot be used with=20
  <SAMP>`-+'</SAMP>.=20
  <DT><SAMP>`-I'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> to generate an <EM>interactive</EM> =
scanner.=20
  An interactive scanner is one that only looks ahead to decide what =
token has=20
  been matched if it absolutely must. It turns out that always looking =
one extra=20
  character ahead, even if the scanner has already seen enough text to=20
  disambiguate the current token, is a bit faster than only looking =
ahead when=20
  necessary. But scanners that always look ahead give dreadful =
interactive=20
  performance; for example, when a user types a newline, it is not =
recognized as=20
  a newline token until they enter <EM>another</EM> token, which often =
means=20
  typing in another whole line. <CODE>Flex</CODE> scanners default to=20
  <EM>interactive</EM> unless you use the <SAMP>`-Cf'</SAMP> or=20
  <SAMP>`-CF'</SAMP> table-compression options (see below). That's =
because if=20
  you're looking for high-performance you should be using one of these =
options,=20
  so if you didn't, <CODE>flex</CODE> assumes you'd rather trade off a =
bit of=20
  run-time performance for intuitive interactive behavior. Note also =
that you=20
  <EM>cannot</EM> use <SAMP>`-I'</SAMP> in conjunction with =
<SAMP>`-Cf'</SAMP>=20
  or <SAMP>`-CF'</SAMP>. Thus, this option is not really needed; it is =
on by=20
  default for all those cases in which it is allowed. You can force a =
scanner to=20
  <EM>not</EM> be interactive by using <SAMP>`-B'</SAMP> (see above).=20
  <DT><SAMP>`-L'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> not to generate <SAMP>`#line'</SAMP>=20
  directives. Without this option, <CODE>flex</CODE> peppers the =
generated=20
  scanner with #line directives so error messages in the actions will be =

  correctly located with respect to either the original =
<CODE>flex</CODE> input=20
  file (if the errors are due to code in the input file), or =
<TT>`lex.yy.c'</TT>=20
  (if the errors are <CODE>flex's</CODE> fault -- you should report =
these sorts=20
  of errors to the email address given below).=20
  <DT><SAMP>`-T'</SAMP>=20
  <DD>makes <CODE>flex</CODE> run in <CODE>trace</CODE> mode. It will =
generate a=20
  lot of messages to <CODE>stderr</CODE> concerning the form of the =
input and=20
  the resultant non-deterministic and deterministic finite automata. =
This option=20
  is mostly for use in maintaining <CODE>flex</CODE>.=20
  <DT><SAMP>`-V'</SAMP>=20
  <DD>prints the version number to <CODE>stdout</CODE> and exits.=20
  <SAMP>`--version'</SAMP> is a synonym for <SAMP>`-V'</SAMP>.=20
  <DT><SAMP>`-7'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> to generate a 7-bit scanner, i.e., one =
which=20
  can only recognized 7-bit characters in its input. The advantage of =
using=20
  <SAMP>`-7'</SAMP> is that the scanner's tables can be up to half the =
size of=20
  those generated using the <SAMP>`-8'</SAMP> option (see below). The=20
  disadvantage is that such scanners often hang or crash if their input =
contains=20
  an 8-bit character. Note, however, that unless you generate your =
scanner using=20
  the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> table compression =
options, use of=20
  <SAMP>`-7'</SAMP> will save only a small amount of table space, and =
make your=20
  scanner considerably less portable. <CODE>Flex's</CODE> default =
behavior is to=20
  generate an 8-bit scanner unless you use the <SAMP>`-Cf'</SAMP> or=20
  <SAMP>`-CF'</SAMP>, in which case <CODE>flex</CODE> defaults to =
generating=20
  7-bit scanners unless your site was always configured to generate =
8-bit=20
  scanners (as will often be the case with non-USA sites). You can tell =
whether=20
  flex generated a 7-bit or an 8-bit scanner by inspecting the flag =
summary in=20
  the <SAMP>`-v'</SAMP> output as described above. Note that if you use=20
  <SAMP>`-Cfe'</SAMP> or <SAMP>`-CFe'</SAMP> (those table compression =
options,=20
  but also using equivalence classes as discussed see below), flex still =

  defaults to generating an 8-bit scanner, since usually with these =
compression=20
  options full 8-bit tables are not much more expensive than 7-bit =
tables.=20
  <DT><SAMP>`-8'</SAMP>=20
  <DD>instructs <CODE>flex</CODE> to generate an 8-bit scanner, i.e., =
one which=20
  can recognize 8-bit characters. This flag is only needed for scanners=20
  generated using <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>, as otherwise =
flex=20
  defaults to generating an 8-bit scanner anyway. See the discussion of=20
  <SAMP>`-7'</SAMP> above for flex's default behavior and the tradeoffs =
between=20
  7-bit and 8-bit scanners.=20
  <DT><SAMP>`-+'</SAMP>=20
  <DD>specifies that you want flex to generate a C++ scanner class. See =
the=20
  section on Generating C++ Scanners below for details.=20
  <DT><SAMP>`-C[aefFmr]'</SAMP>=20
  <DD>controls the degree of table compression and, more generally, =
trade-offs=20
  between small scanners and fast scanners. <SAMP>`-Ca'</SAMP> ("align") =

  instructs flex to trade off larger tables in the generated scanner for =
faster=20
  performance because the elements of the tables are better aligned for =
memory=20
  access and computation. On some RISC architectures, fetching and =
manipulating=20
  long-words is more efficient than with smaller-sized units such as =
shortwords.=20
  This option can double the size of the tables used by your scanner.=20
  <SAMP>`-Ce'</SAMP> directs <CODE>flex</CODE> to construct =
<EM>equivalence=20
  classes</EM>, i.e., sets of characters which have identical lexical =
properties=20
  (for example, if the only appearance of digits in the =
<CODE>flex</CODE> input=20
  is in the character class "[0-9]" then the digits '0', '1', ..., '9' =
will all=20
  be put in the same equivalence class). Equivalence classes usually =
give=20
  dramatic reductions in the final table/object file sizes (typically a =
factor=20
  of 2-5) and are pretty cheap performance-wise (one array look-up per =
character=20
  scanned). <SAMP>`-Cf'</SAMP> specifies that the <EM>full</EM> scanner =
tables=20
  should be generated - <CODE>flex</CODE> should not compress the tables =
by=20
  taking advantages of similar transition functions for different =
states.=20
  <SAMP>`-CF'</SAMP> specifies that the alternate fast scanner =
representation=20
  (described above under the <SAMP>`-F'</SAMP> flag) should be used. =
This option=20
  cannot be used with <SAMP>`-+'</SAMP>. <SAMP>`-Cm'</SAMP> directs=20
  <CODE>flex</CODE> to construct <EM>meta-equivalence classes</EM>, =
which are=20
  sets of equivalence classes (or characters, if equivalence classes are =
not=20
  being used) that are commonly used together. Meta-equivalence classes =
are=20
  often a big win when using compressed tables, but they have a moderate =

  performance impact (one or two "if" tests and one array look-up per =
character=20
  scanned). <SAMP>`-Cr'</SAMP> causes the generated scanner to =
<EM>bypass</EM>=20
  use of the standard I/O library (stdio) for input. Instead of calling=20
  <SAMP>`fread()'</SAMP> or <SAMP>`getc()'</SAMP>, the scanner will use =
the=20
  <SAMP>`read()'</SAMP> system call, resulting in a performance gain =
which=20
  varies from system to system, but in general is probably negligible =
unless you=20
  are also using <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP>. Using=20
  <SAMP>`-Cr'</SAMP> can cause strange behavior if, for example, you =
read from=20
  <CODE>yyin</CODE> using stdio prior to calling the scanner (because =
the=20
  scanner will miss whatever text your previous reads left in the stdio =
input=20
  buffer). <SAMP>`-Cr'</SAMP> has no effect if you define =
<CODE>YY_INPUT</CODE>=20
  (see The Generated Scanner above). A lone <SAMP>`-C'</SAMP> specifies =
that the=20
  scanner tables should be compressed but neither equivalence classes =
nor=20
  meta-equivalence classes should be used. The options =
<SAMP>`-Cf'</SAMP> or=20
  <SAMP>`-CF'</SAMP> and <SAMP>`-Cm'</SAMP> do not make sense together - =
there=20
  is no opportunity for meta-equivalence classes if the table is not =
being=20
  compressed. Otherwise the options may be freely mixed, and are =
cumulative. The=20
  default setting is <SAMP>`-Cem'</SAMP>, which specifies that =
<CODE>flex</CODE>=20
  should generate equivalence classes and meta-equivalence classes. This =
setting=20
  provides the highest degree of table compression. You can trade off=20
  faster-executing scanners at the cost of larger tables with the =
following=20
  generally being true: <PRE>slowest &amp; smallest
      -Cem
      -Cm
      -Ce
      -C
      -C{f,F}e
      -C{f,F}
      -C{f,F}a
fastest &amp; largest
</PRE>Note that scanners with the smallest tables are usually generated =
and=20
  compiled the quickest, so during development you will usually want to =
use the=20
  default, maximal compression. <SAMP>`-Cfe'</SAMP> is often a good =
compromise=20
  between speed and size for production scanners.=20
  <DT><SAMP>`-ooutput'</SAMP>=20
  <DD>directs flex to write the scanner to the file <SAMP>`out-'</SAMP>=20
  <CODE>put</CODE> instead of <TT>`lex.yy.c'</TT>. If you combine=20
  <SAMP>`-o'</SAMP> with the <SAMP>`-t'</SAMP> option, then the scanner =
is=20
  written to <CODE>stdout</CODE> but its <SAMP>`#line'</SAMP> directives =
(see=20
  the <SAMP>`-L'</SAMP> option above) refer to the file =
<CODE>output</CODE>.=20
  <DT><SAMP>`-Pprefix'</SAMP>=20
  <DD>changes the default <SAMP>`yy'</SAMP> prefix used by =
<CODE>flex</CODE> for=20
  all globally-visible variable and function names to instead be=20
  <VAR>prefix</VAR>. For example, <SAMP>`-Pfoo'</SAMP> changes the name =
of=20
  <CODE>yytext</CODE> to <TT>`footext'</TT>. It also changes the name of =
the=20
  default output file from <TT>`lex.yy.c'</TT> to <TT>`lex.foo.c'</TT>. =
Here are=20
  all of the names affected: <PRE>yy_create_buffer
yy_delete_buffer
yy_flex_debug
yy_init_buffer
yy_flush_buffer
yy_load_buffer_state
yy_switch_to_buffer
yyin
yyleng
yylex
yylineno
yyout
yyrestart
yytext
yywrap
</PRE>(If you are using a C++ scanner, then only <CODE>yywrap</CODE> and =

  <CODE>yyFlexLexer</CODE> are affected.) Within your scanner itself, =
you can=20
  still refer to the global variables and functions using either version =
of=20
  their name; but externally, they have the modified name. This option =
lets you=20
  easily link together multiple <CODE>flex</CODE> programs into the same =

  executable. Note, though, that using this option also renames=20
  <SAMP>`yywrap()'</SAMP>, so you now <EM>must</EM> either provide your =
own=20
  (appropriately-named) version of the routine for your scanner, or use=20
  <SAMP>`%option noyywrap'</SAMP>, as linking with <SAMP>`-lfl'</SAMP> =
no longer=20
  provides one for you by default.=20
  <DT><SAMP>`-Sskeleton_file'</SAMP>=20
  <DD>overrides the default skeleton file from which <CODE>flex</CODE>=20
  constructs its scanners. You'll never need this option unless you are =
doing=20
  <CODE>flex</CODE> maintenance or development. </DD></DL>
<P><CODE>flex</CODE> also provides a mechanism for controlling options =
within=20
the scanner specification itself, rather than from the flex =
command-line. This=20
is done by including <SAMP>`%option'</SAMP> directives in the first =
section of=20
the scanner specification. You can specify multiple options with a =
single=20
<SAMP>`%option'</SAMP> directive, and multiple directives in the first =
section=20
of your flex input file. Most options are given simply as names, =
optionally=20
preceded by the word "no" (with no intervening whitespace) to negate =
their=20
meaning. A number are equivalent to flex flags or their negation: =
<PRE>7bit            -7 option
8bit            -8 option
align           -Ca option
backup          -b option
batch           -B option
c++             -+ option

caseful or
case-sensitive  opposite of -i (default)

case-insensitive or
caseless        -i option

debug           -d option
default         opposite of -s option
ecs             -Ce option
fast            -F option
full            -f option
interactive     -I option
lex-compat      -l option
meta-ecs        -Cm option
perf-report     -p option
read            -Cr option
stdout          -t option
verbose         -v option
warn            opposite of -w option
                (use "%option nowarn" for -w)

array           equivalent to "%array"
pointer         equivalent to "%pointer" (default)
</PRE>
<P>Some <SAMP>`%option's'</SAMP> provide features otherwise not =
available:=20
<DL compact>
  <DT><SAMP>`always-interactive'</SAMP>=20
  <DD>instructs flex to generate a scanner which always considers its =
input=20
  "interactive". Normally, on each new input file the scanner calls=20
  <SAMP>`isatty()'</SAMP> in an attempt to determine whether the =
scanner's input=20
  source is interactive and thus should be read a character at a time. =
When this=20
  option is used, however, then no such call is made.=20
  <DT><SAMP>`main'</SAMP>=20
  <DD>directs flex to provide a default <SAMP>`main()'</SAMP> program =
for the=20
  scanner, which simply calls <SAMP>`yylex()'</SAMP>. This option =
implies=20
  <CODE>noyywrap</CODE> (see below).=20
  <DT><SAMP>`never-interactive'</SAMP>=20
  <DD>instructs flex to generate a scanner which never considers its =
input=20
  "interactive" (again, no call made to <SAMP>`isatty())'</SAMP>. This =
is the=20
  opposite of <SAMP>`always-'</SAMP> <EM>interactive</EM>.=20
  <DT><SAMP>`stack'</SAMP>=20
  <DD>enables the use of start condition stacks (see Start Conditions =
above).=20
  <DT><SAMP>`stdinit'</SAMP>=20
  <DD>if unset (i.e., <SAMP>`%option nostdinit'</SAMP>) initializes=20
  <CODE>yyin</CODE> and <CODE>yyout</CODE> to nil <CODE>FILE</CODE> =
pointers,=20
  instead of <CODE>stdin</CODE> and <CODE>stdout</CODE>.=20
  <DT><SAMP>`yylineno'</SAMP>=20
  <DD>directs <CODE>flex</CODE> to generate a scanner that maintains the =
number=20
  of the current line read from its input in the global variable=20
  <CODE>yylineno</CODE>. This option is implied by <SAMP>`%option=20
  lex-compat'</SAMP>.=20
  <DT><SAMP>`yywrap'</SAMP>=20
  <DD>if unset (i.e., <SAMP>`%option noyywrap'</SAMP>), makes the =
scanner not=20
  call <SAMP>`yywrap()'</SAMP> upon an end-of-file, but simply assume =
that there=20
  are no more files to scan (until the user points <CODE>yyin</CODE> at =
a new=20
  file and calls <SAMP>`yylex()'</SAMP> again). </DD></DL>
<P><CODE>flex</CODE> scans your rule actions to determine whether you =
use the=20
<CODE>REJECT</CODE> or <SAMP>`yymore()'</SAMP> features. The =
<CODE>reject</CODE>=20
and <CODE>yymore</CODE> options are available to override its decision =
as to=20
whether you use the options, either by setting them (e.g., =
<SAMP>`%option=20
reject'</SAMP>) to indicate the feature is indeed used, or unsetting =
them to=20
indicate it actually is not used (e.g., <SAMP>`%option =
noyymore'</SAMP>).=20
<P>Three options take string-delimited values, offset with '=3D': =
<PRE>%option outfile=3D"ABC"
</PRE>
<P>is equivalent to <SAMP>`-oABC'</SAMP>, and <PRE>%option =
prefix=3D"XYZ"
</PRE>
<P>is equivalent to <SAMP>`-PXYZ'</SAMP>.=20
<P>Finally, <PRE>%option yyclass=3D"foo"
</PRE>
<P>only applies when generating a C++ scanner (<SAMP>`-+'</SAMP> =
option). It=20
informs <CODE>flex</CODE> that you have derived <SAMP>`foo'</SAMP> as a =
subclass=20
of <CODE>yyFlexLexer</CODE> so <CODE>flex</CODE> will place your actions =
in the=20
member function <SAMP>`foo::yylex()'</SAMP> instead of=20
<SAMP>`yyFlexLexer::yylex()'</SAMP>. It also generates a=20
<SAMP>`yyFlexLexer::yylex()'</SAMP> member function that emits a =
run-time error=20
(by invoking <SAMP>`yyFlexLexer::LexerError()'</SAMP>) if called. See =
Generating=20
C++ Scanners, below, for additional information.=20
<P>A number of options are available for lint purists who want to =
suppress the=20
appearance of unneeded routines in the generated scanner. Each of the =
following,=20
if unset, results in the corresponding routine not appearing in the =
generated=20
scanner: <PRE>input, unput
yy_push_state, yy_pop_state, yy_top_state
yy_scan_buffer, yy_scan_bytes, yy_scan_string
</PRE>
<P>(though <SAMP>`yy_push_state()'</SAMP> and friends won't appear =
anyway unless=20
you use <SAMP>`%option stack'</SAMP>).=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC18"=20
name=3DSEC18>Performance considerations</A></H2>
<P>The main design goal of <CODE>flex</CODE> is that it generate=20
high-performance scanners. It has been optimized for dealing well with =
large=20
sets of rules. Aside from the effects on scanner speed of the table =
compression=20
<SAMP>`-C'</SAMP> options outlined above, there are a number of =
options/actions=20
which degrade performance. These are, from most expensive to least: =
<PRE>REJECT
%option yylineno
arbitrary trailing context

pattern sets that require backing up
%array
%option interactive
%option always-interactive

'^' beginning-of-line operator
yymore()
</PRE>
<P>with the first three all being quite expensive and the last two being =
quite=20
cheap. Note also that <SAMP>`unput()'</SAMP> is implemented as a routine =
call=20
that potentially does quite a bit of work, while <SAMP>`yyless()'</SAMP> =
is a=20
quite-cheap macro; so if just putting back some excess text you scanned, =
use=20
<SAMP>`yyless()'</SAMP>.=20
<P><CODE>REJECT</CODE> should be avoided at all costs when performance =
is=20
important. It is a particularly expensive option.=20
<P>Getting rid of backing up is messy and often may be an enormous =
amount of=20
work for a complicated scanner. In principal, one begins by using the=20
<SAMP>`-b'</SAMP> flag to generate a <TT>`lex.backup'</TT> file. For =
example, on=20
the input <PRE>%%
foo        return TOK_KEYWORD;
foobar     return TOK_KEYWORD;
</PRE>
<P>the file looks like: <PRE>State #6 is non-accepting -
 associated rule line numbers:
       2       3
 out-transitions: [ o ]
 jam-transitions: EOF [ \001-n  p-\177 ]

State #8 is non-accepting -
 associated rule line numbers:
       3
 out-transitions: [ a ]
 jam-transitions: EOF [ \001-`  b-\177 ]

State #9 is non-accepting -
 associated rule line numbers:
       3
 out-transitions: [ r ]
 jam-transitions: EOF [ \001-q  s-\177 ]

Compressed tables always back up.
</PRE>
<P>The first few lines tell us that there's a scanner state in which it =
can make=20
a transition on an 'o' but not on any other character, and that in that =
state=20
the currently scanned text does not match any rule. The state occurs =
when trying=20
to match the rules found at lines 2 and 3 in the input file. If the =
scanner is=20
in that state and then reads something other than an 'o', it will have =
to back=20
up to find a rule which is matched. With a bit of head-scratching one =
can see=20
that this must be the state it's in when it has seen "fo". When this has =

happened, if anything other than another 'o' is seen, the scanner will =
have to=20
back up to simply match the 'f' (by the default rule).=20
<P>The comment regarding State #8 indicates there's a problem when =
"foob" has=20
been scanned. Indeed, on any character other than an 'a', the scanner =
will have=20
to back up to accept "foo". Similarly, the comment for State #9 concerns =
when=20
"fooba" has been scanned and an 'r' does not follow.=20
<P>The final comment reminds us that there's no point going to all the =
trouble=20
of removing backing up from the rules unless we're using =
<SAMP>`-Cf'</SAMP> or=20
<SAMP>`-CF'</SAMP>, since there's no performance gain doing so with =
compressed=20
scanners.=20
<P>The way to remove the backing up is to add "error" rules: <PRE>%%
foo         return TOK_KEYWORD;
foobar      return TOK_KEYWORD;

fooba       |
foob        |
fo          {
            /* false alarm, not really a keyword */
            return TOK_ID;
            }
</PRE>
<P>Eliminating backing up among a list of keywords can also be done =
using a=20
"catch-all" rule: <PRE>%%
foo         return TOK_KEYWORD;
foobar      return TOK_KEYWORD;

[a-z]+      return TOK_ID;
</PRE>
<P>This is usually the best solution when appropriate.=20
<P>Backing up messages tend to cascade. With a complicated set of rules =
it's not=20
uncommon to get hundreds of messages. If one can decipher them, though, =
it often=20
only takes a dozen or so rules to eliminate the backing up (though it's =
easy to=20
make a mistake and have an error rule accidentally match a valid token. =
A=20
possible future <CODE>flex</CODE> feature will be to automatically add =
rules to=20
eliminate backing up).=20
<P>It's important to keep in mind that you gain the benefits of =
eliminating=20
backing up only if you eliminate <EM>every</EM> instance of backing up. =
Leaving=20
just one means you gain nothing.=20
<P><VAR>Variable</VAR> trailing context (where both the leading and =
trailing=20
parts do not have a fixed length) entails almost the same performance =
loss as=20
<CODE>REJECT</CODE> (i.e., substantial). So when possible a rule like: =
<PRE>%%
mouse|rat/(cat|dog)   run();
</PRE>
<P>is better written: <PRE>%%
mouse/cat|dog         run();
rat/cat|dog           run();
</PRE>
<P>or as <PRE>%%
mouse|rat/cat         run();
mouse|rat/dog         run();
</PRE>
<P>Note that here the special '|' action does <EM>not</EM> provide any =
savings,=20
and can even make things worse (see Deficiencies / Bugs below).=20
<P>Another area where the user can increase a scanner's performance (and =
one=20
that's easier to implement) arises from the fact that the longer the =
tokens=20
matched, the faster the scanner will run. This is because with long =
tokens the=20
processing of most input characters takes place in the (short) inner =
scanning=20
loop, and does not often have to go through the additional work of =
setting up=20
the scanning environment (e.g., <CODE>yytext</CODE>) for the action. =
Recall the=20
scanner for C comments: <PRE>%x comment
%%
        int line_num =3D 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*
&lt;comment&gt;"*"+[^*/\n]*
&lt;comment&gt;\n             ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</PRE>
<P>This could be sped up by writing it as: <PRE>%x comment
%%
        int line_num =3D 1;

"/*"         BEGIN(comment);

&lt;comment&gt;[^*\n]*
&lt;comment&gt;[^*\n]*\n      ++line_num;
&lt;comment&gt;"*"+[^*/\n]*
&lt;comment&gt;"*"+[^*/\n]*\n ++line_num;
&lt;comment&gt;"*"+"/"        BEGIN(INITIAL);
</PRE>
<P>Now instead of each newline requiring the processing of another =
action,=20
recognizing the newlines is "distributed" over the other rules to keep =
the=20
matched text as long as possible. Note that <EM>adding</EM> rules does=20
<EM>not</EM> slow down the scanner! The speed of the scanner is =
independent of=20
the number of rules or (modulo the considerations given at the beginning =
of this=20
section) how complicated the rules are with regard to operators such as =
'*' and=20
'|'.=20
<P>A final example in speeding up a scanner: suppose you want to scan =
through a=20
file containing identifiers and keywords, one per line and with no other =

extraneous characters, and recognize all the keywords. A natural first =
approach=20
is: <PRE>%%
asm      |
auto     |
break    |
... etc ...
volatile |
while    /* it's a keyword */

.|\n     /* it's not a keyword */
</PRE>
<P>To eliminate the back-tracking, introduce a catch-all rule: <PRE>%%
asm      |
auto     |
break    |
... etc ...
volatile |
while    /* it's a keyword */

[a-z]+   |
.|\n     /* it's not a keyword */
</PRE>
<P>Now, if it's guaranteed that there's exactly one word per line, then =
we can=20
reduce the total number of matches by a half by merging in the =
recognition of=20
newlines with that of the other tokens: <PRE>%%
asm\n    |
auto\n   |
break\n  |
... etc ...
volatile\n |
while\n  /* it's a keyword */

[a-z]+\n |
.|\n     /* it's not a keyword */
</PRE>
<P>One has to be careful here, as we have now reintroduced backing up =
into the=20
scanner. In particular, while <EM>we</EM> know that there will never be =
any=20
characters in the input stream other than letters or newlines, =
<CODE>flex</CODE>=20
can't figure this out, and it will plan for possibly needing to back up =
when it=20
has scanned a token like "auto" and then the next character is something =
other=20
than a newline or a letter. Previously it would then just match the =
"auto" rule=20
and be done, but now it has no "auto" rule, only a "auto\n" rule. To =
eliminate=20
the possibility of backing up, we could either duplicate all rules but =
without=20
final newlines, or, since we never expect to encounter such an input and =

therefore don't how it's classified, we can introduce one more catch-all =
rule,=20
this one which doesn't include a newline: <PRE>%%
asm\n    |
auto\n   |
break\n  |
... etc ...
volatile\n |
while\n  /* it's a keyword */

[a-z]+\n |
[a-z]+   |
.|\n     /* it's not a keyword */
</PRE>
<P>Compiled with <SAMP>`-Cf'</SAMP>, this is about as fast as one can =
get a=20
<CODE>flex</CODE> scanner to go for this particular problem.=20
<P>A final note: <CODE>flex</CODE> is slow when matching NUL's, =
particularly=20
when a token contains multiple NUL's. It's best to write rules which =
match=20
<EM>short</EM> amounts of text if it's anticipated that the text will =
often=20
include NUL's.=20
<P>Another final note regarding performance: as mentioned above in the =
section=20
How the Input is Matched, dynamically resizing <CODE>yytext</CODE> to=20
accommodate huge tokens is a slow process because it presently requires =
that the=20
(huge) token be rescanned from the beginning. Thus if performance is =
vital, you=20
should attempt to match "large" quantities of text but not "huge" =
quantities,=20
where the cutoff between the two is at about 8K characters/token.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC19"=20
name=3DSEC19>Generating C++ scanners</A></H2>
<P><CODE>flex</CODE> provides two different ways to generate scanners =
for use=20
with C++. The first way is to simply compile a scanner generated by=20
<CODE>flex</CODE> using a C++ compiler instead of a C compiler. You =
should not=20
encounter any compilations errors (please report any you find to the =
email=20
address given in the Author section below). You can then use C++ code in =
your=20
rule actions instead of C code. Note that the default input source for =
your=20
scanner remains <CODE>yyin</CODE>, and default echoing is still done to=20
<CODE>yyout</CODE>. Both of these remain <SAMP>`FILE *'</SAMP> variables =
and not=20
C++ <CODE>streams</CODE>.=20
<P>You can also use <CODE>flex</CODE> to generate a C++ scanner class, =
using the=20
<SAMP>`-+'</SAMP> option, (or, equivalently, <SAMP>`%option =
c++'</SAMP>), which=20
is automatically specified if the name of the flex executable ends in a=20
<SAMP>`+'</SAMP>, such as <CODE>flex++</CODE>. When using this option, =
flex=20
defaults to generating the scanner to the file <TT>`lex.yy.cc'</TT> =
instead of=20
<TT>`lex.yy.c'</TT>. The generated scanner includes the header file=20
<TT>`FlexLexer.h'</TT>, which defines the interface to two C++ classes.=20
<P>The first class, <CODE>FlexLexer</CODE>, provides an abstract base =
class=20
defining the general scanner class interface. It provides the following =
member=20
functions:=20
<DL compact>
  <DT><SAMP>`const char* YYText()'</SAMP>=20
  <DD>returns the text of the most recently matched token, the =
equivalent of=20
  <CODE>yytext</CODE>.=20
  <DT><SAMP>`int YYLeng()'</SAMP>=20
  <DD>returns the length of the most recently matched token, the =
equivalent of=20
  <CODE>yyleng</CODE>.=20
  <DT><SAMP>`int lineno() const'</SAMP>=20
  <DD>returns the current input line number (see <SAMP>`%option=20
  yylineno'</SAMP>), or 1 if <SAMP>`%option yylineno'</SAMP> was not =
used.=20
  <DT><SAMP>`void set_debug( int flag )'</SAMP>=20
  <DD>sets the debugging flag for the scanner, equivalent to assigning =
to=20
  <CODE>yy_flex_debug</CODE> (see the Options section above). Note that =
you must=20
  build the scanner using <SAMP>`%option debug'</SAMP> to include =
debugging=20
  information in it.=20
  <DT><SAMP>`int debug() const'</SAMP>=20
  <DD>returns the current setting of the debugging flag. </DD></DL>
<P>Also provided are member functions equivalent to=20
<SAMP>`yy_switch_to_buffer(), yy_create_buffer()'</SAMP> (though the =
first=20
argument is an <SAMP>`istream*'</SAMP> object pointer and not a=20
<SAMP>`FILE*'</SAMP>, <SAMP>`yy_flush_buffer()'</SAMP>,=20
<SAMP>`yy_delete_buffer()'</SAMP>, and <SAMP>`yyrestart()'</SAMP> =
(again, the=20
first argument is a <SAMP>`istream*'</SAMP> object pointer).=20
<P>The second class defined in <TT>`FlexLexer.h'</TT> is=20
<CODE>yyFlexLexer</CODE>, which is derived from <CODE>FlexLexer</CODE>. =
It=20
defines the following additional member functions:=20
<DL compact>
  <DT><SAMP>`yyFlexLexer( istream* arg_yyin =3D 0, ostream* arg_yyout =
=3D 0=20
  )'</SAMP>=20
  <DD>constructs a <CODE>yyFlexLexer</CODE> object using the given =
streams for=20
  input and output. If not specified, the streams default to =
<CODE>cin</CODE>=20
  and <CODE>cout</CODE>, respectively.=20
  <DT><SAMP>`virtual int yylex()'</SAMP>=20
  <DD>performs the same role is <SAMP>`yylex()'</SAMP> does for ordinary =
flex=20
  scanners: it scans the input stream, consuming tokens, until a rule's =
action=20
  returns a value. If you derive a subclass <VAR>S</VAR> from=20
  <CODE>yyFlexLexer</CODE> and want to access the member functions and =
variables=20
  of <VAR>S</VAR> inside <SAMP>`yylex()'</SAMP>, then you need to use=20
  <SAMP>`%option yyclass=3D"<VAR>S</VAR>"'</SAMP> to inform =
<CODE>flex</CODE> that=20
  you will be using that subclass instead of <CODE>yyFlexLexer</CODE>. =
In this=20
  case, rather than generating <SAMP>`yyFlexLexer::yylex()'</SAMP>,=20
  <CODE>flex</CODE> generates <SAMP>`<VAR>S</VAR>::yylex()'</SAMP> (and =
also=20
  generates a dummy <SAMP>`yyFlexLexer::yylex()'</SAMP> that calls=20
  <SAMP>`yyFlexLexer::LexerError()'</SAMP> if called).=20
  <DT><SAMP>`virtual void switch_streams(istream* new_in =3D 0, ostream* =
new_out =3D=20
  0)'</SAMP>=20
  <DD>reassigns <CODE>yyin</CODE> to <CODE>new_in</CODE> (if non-nil) =
and=20
  <CODE>yyout</CODE> to <CODE>new_out</CODE> (ditto), deleting the =
previous=20
  input buffer if <CODE>yyin</CODE> is reassigned.=20
  <DT><SAMP>`int yylex( istream* new_in =3D 0, ostream* new_out =3D 0 =
)'</SAMP>=20
  <DD>first switches the input streams via <SAMP>`switch_streams( =
new_in,=20
  new_out )'</SAMP> and then returns the value of =
<SAMP>`yylex()'</SAMP>.=20
</DD></DL>
<P>In addition, <CODE>yyFlexLexer</CODE> defines the following protected =
virtual=20
functions which you can redefine in derived classes to tailor the =
scanner:=20
<DL compact>
  <DT><SAMP>`virtual int LexerInput( char* buf, int max_size )'</SAMP>=20
  <DD>reads up to <SAMP>`max_size'</SAMP> characters into <VAR>buf</VAR> =
and=20
  returns the number of characters read. To indicate end-of-input, =
return 0=20
  characters. Note that "interactive" scanners (see the =
<SAMP>`-B'</SAMP> and=20
  <SAMP>`-I'</SAMP> flags) define the macro <CODE>YY_INTERACTIVE</CODE>. =
If you=20
  redefine <CODE>LexerInput()</CODE> and need to take different actions=20
  depending on whether or not the scanner might be scanning an =
interactive input=20
  source, you can test for the presence of this name via =
<SAMP>`#ifdef'</SAMP>.=20
  <DT><SAMP>`virtual void LexerOutput( const char* buf, int size =
)'</SAMP>=20
  <DD>writes out <VAR>size</VAR> characters from the buffer =
<VAR>buf</VAR>,=20
  which, while NUL-terminated, may also contain "internal" NUL's if the=20
  scanner's rules can match text with NUL's in them.=20
  <DT><SAMP>`virtual void LexerError( const char* msg )'</SAMP>=20
  <DD>reports a fatal error message. The default version of this =
function writes=20
  the message to the stream <CODE>cerr</CODE> and exits. </DD></DL>
<P>Note that a <CODE>yyFlexLexer</CODE> object contains its =
<EM>entire</EM>=20
scanning state. Thus you can use such objects to create reentrant =
scanners. You=20
can instantiate multiple instances of the same <CODE>yyFlexLexer</CODE> =
class,=20
and you can also combine multiple C++ scanner classes together in the =
same=20
program using the <SAMP>`-P'</SAMP> option discussed above. Finally, =
note that=20
the <SAMP>`%array'</SAMP> feature is not available to C++ scanner =
classes; you=20
must use <SAMP>`%pointer'</SAMP> (the default).=20
<P>Here is an example of a simple C++ scanner: <PRE>    // An example of =
using the flex C++ scanner class.

%{
int mylineno =3D 0;
%}

string  \"[^\n"]+\"

ws      [ \t]+

alpha   [A-Za-z]
dig     [0-9]
name    ({alpha}|{dig}|\$)({alpha}|{dig}|[_.\-/$])*
num1    [-+]?{dig}+\.?([eE][-+]?{dig}+)?
num2    [-+]?{dig}*\.{dig}+([eE][-+]?{dig}+)?
number  {num1}|{num2}

%%

{ws}    /* skip blanks and tabs */

"/*"    {
        int c;

        while((c =3D yyinput()) !=3D 0)
            {
            if(c =3D=3D '\n')
                ++mylineno;

            else if(c =3D=3D '*')
                {
                if((c =3D yyinput()) =3D=3D '/')
                    break;
                else
                    unput(c);
                }
            }
        }

{number}  cout &lt;&lt; "number " &lt;&lt; YYText() &lt;&lt; '\n';

\n        mylineno++;

{name}    cout &lt;&lt; "name " &lt;&lt; YYText() &lt;&lt; '\n';

{string}  cout &lt;&lt; "string " &lt;&lt; YYText() &lt;&lt; '\n';

%%

Version 2.5               December 1994                        44

int main( int /* argc */, char** /* argv */ )
    {
    FlexLexer* lexer =3D new yyFlexLexer;
    while(lexer-&gt;yylex() !=3D 0)
        ;
    return 0;
    }
</PRE>
<P>If you want to create multiple (different) lexer classes, you use the =

<SAMP>`-P'</SAMP> flag (or the <SAMP>`prefix=3D'</SAMP> option) to =
rename each=20
<CODE>yyFlexLexer</CODE> to some other <CODE>xxFlexLexer</CODE>. You =
then can=20
include <SAMP>`&lt;FlexLexer.h&gt;'</SAMP> in your other sources once =
per lexer=20
class, first renaming <CODE>yyFlexLexer</CODE> as follows: <PRE>#undef =
yyFlexLexer
#define yyFlexLexer xxFlexLexer
#include &lt;FlexLexer.h&gt;

#undef yyFlexLexer
#define yyFlexLexer zzFlexLexer
#include &lt;FlexLexer.h&gt;
</PRE>
<P>if, for example, you used <SAMP>`%option prefix=3D"xx"'</SAMP> for =
one of your=20
scanners and <SAMP>`%option prefix=3D"zz"'</SAMP> for the other.=20
<P>IMPORTANT: the present form of the scanning class is =
<EM>experimental</EM>=20
and may change considerably between major releases.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC20"=20
name=3DSEC20>Incompatibilities with <CODE>lex</CODE> and POSIX</A></H2>
<P><CODE>flex</CODE> is a rewrite of the AT&amp;T Unix <CODE>lex</CODE> =
tool=20
(the two implementations do not share any code, though), with some =
extensions=20
and incompatibilities, both of which are of concern to those who wish to =
write=20
scanners acceptable to either implementation. Flex is fully compliant =
with the=20
POSIX <CODE>lex</CODE> specification, except that when using=20
<SAMP>`%pointer'</SAMP> (the default), a call to <SAMP>`unput()'</SAMP> =
destroys=20
the contents of <CODE>yytext</CODE>, which is counter to the POSIX=20
specification.=20
<P>In this section we discuss all of the known areas of incompatibility =
between=20
flex, AT&amp;T lex, and the POSIX specification.=20
<P><CODE>flex's</CODE> <SAMP>`-l'</SAMP> option turns on maximum =
compatibility=20
with the original AT&amp;T <CODE>lex</CODE> implementation, at the cost =
of a=20
major loss in the generated scanner's performance. We note below which=20
incompatibilities can be overcome using the <SAMP>`-l'</SAMP> option.=20
<P><CODE>flex</CODE> is fully compatible with <CODE>lex</CODE> with the=20
following exceptions:=20
<UL>
  <LI>The undocumented <CODE>lex</CODE> scanner internal variable=20
  <CODE>yylineno</CODE> is not supported unless <SAMP>`-l'</SAMP> or=20
  <SAMP>`%option yylineno'</SAMP> is used. <CODE>yylineno</CODE> should =
be=20
  maintained on a per-buffer basis, rather than a per-scanner (single =
global=20
  variable) basis. <CODE>yylineno</CODE> is not part of the POSIX =
specification.=20

  <LI>The <SAMP>`input()'</SAMP> routine is not redefinable, though it =
may be=20
  called to read characters following whatever has been matched by a =
rule. If=20
  <SAMP>`input()'</SAMP> encounters an end-of-file the normal=20
  <SAMP>`yywrap()'</SAMP> processing is done. A "real" end-of-file is =
returned=20
  by <SAMP>`input()'</SAMP> as <CODE>EOF</CODE>. Input is instead =
controlled by=20
  defining the <CODE>YY_INPUT</CODE> macro. The <CODE>flex</CODE> =
restriction=20
  that <SAMP>`input()'</SAMP> cannot be redefined is in accordance with =
the=20
  POSIX specification, which simply does not specify any way of =
controlling the=20
  scanner's input other than by making an initial assignment to=20
  <CODE>yyin</CODE>.=20
  <LI>The <SAMP>`unput()'</SAMP> routine is not redefinable. This =
restriction is=20
  in accordance with POSIX.=20
  <LI><CODE>flex</CODE> scanners are not as reentrant as =
<CODE>lex</CODE>=20
  scanners. In particular, if you have an interactive scanner and an =
interrupt=20
  handler which long-jumps out of the scanner, and the scanner is =
subsequently=20
  called again, you may get the following message: <PRE>fatal flex =
scanner internal error--end of buffer missed
</PRE>To reenter the scanner, first use <PRE>yyrestart( yyin );
</PRE>Note that this call will throw away any buffered input; usually =
this=20
  isn't a problem with an interactive scanner. Also note that flex C++ =
scanner=20
  classes <EM>are</EM> reentrant, so if using C++ is an option for you, =
you=20
  should use them instead. See "Generating C++ Scanners" above for =
details.=20
  <LI><SAMP>`output()'</SAMP> is not supported. Output from the=20
  <SAMP>`ECHO'</SAMP> macro is done to the file-pointer =
<CODE>yyout</CODE>=20
  (default <CODE>stdout</CODE>). <SAMP>`output()'</SAMP> is not part of =
the=20
  POSIX specification.=20
  <LI><CODE>lex</CODE> does not support exclusive start conditions (%x), =
though=20
  they are in the POSIX specification.=20
  <LI>When definitions are expanded, <CODE>flex</CODE> encloses them in=20
  parentheses. With lex, the following: <PRE>NAME    [A-Z][A-Z0-9]*
%%
foo{NAME}?      printf( "Found it\n" );
%%
</PRE>will not match the string "foo" because when the macro is expanded =
the=20
  rule is equivalent to "foo[A-Z][A-Z0-9]*?" and the precedence is such =
that the=20
  '?' is associated with "[A-Z0-9]*". With <CODE>flex</CODE>, the rule =
will be=20
  expanded to "foo([A-Z][A-Z0-9]*)?" and so the string "foo" will match. =
Note=20
  that if the definition begins with <SAMP>`^'</SAMP> or ends with=20
  <SAMP>`$'</SAMP> then it is <EM>not</EM> expanded with parentheses, to =
allow=20
  these operators to appear in definitions without losing their special=20
  meanings. But the <SAMP>`&lt;s&gt;, /'</SAMP>, and=20
  <SAMP>`&lt;&lt;EOF&gt;&gt;'</SAMP> operators cannot be used in a=20
  <CODE>flex</CODE> definition. Using <SAMP>`-l'</SAMP> results in the=20
  <CODE>lex</CODE> behavior of no parentheses around the definition. The =
POSIX=20
  specification is that the definition be enclosed in parentheses.=20
  <LI>Some implementations of <CODE>lex</CODE> allow a rule's action to =
begin on=20
  a separate line, if the rule's pattern has trailing whitespace: =
<PRE>%%
foo|bar&lt;space here&gt;
  { foobar_action(); }
</PRE><CODE>flex</CODE> does not support this feature.=20
  <LI>The <CODE>lex</CODE> <SAMP>`%r'</SAMP> (generate a Ratfor scanner) =
option=20
  is not supported. It is not part of the POSIX specification.=20
  <LI>After a call to <SAMP>`unput()'</SAMP>, <CODE>yytext</CODE> is =
undefined=20
  until the next token is matched, unless the scanner was built using=20
  <SAMP>`%array'</SAMP>. This is not the case with <CODE>lex</CODE> or =
the POSIX=20
  specification. The <SAMP>`-l'</SAMP> option does away with this=20
  incompatibility.=20
  <LI>The precedence of the <SAMP>`{}'</SAMP> (numeric range) operator =
is=20
  different. <CODE>lex</CODE> interprets "abc{1,3}" as "match one, two, =
or three=20
  occurrences of 'abc'", whereas <CODE>flex</CODE> interprets it as =
"match 'ab'=20
  followed by one, two, or three occurrences of 'c'". The latter is in =
agreement=20
  with the POSIX specification.=20
  <LI>The precedence of the <SAMP>`^'</SAMP> operator is different.=20
  <CODE>lex</CODE> interprets "^foo|bar" as "match either 'foo' at the =
beginning=20
  of a line, or 'bar' anywhere", whereas <CODE>flex</CODE> interprets it =
as=20
  "match either 'foo' or 'bar' if they come at the beginning of a line". =
The=20
  latter is in agreement with the POSIX specification.=20
  <LI>The special table-size declarations such as <SAMP>`%a'</SAMP> =
supported by=20
  <CODE>lex</CODE> are not required by <CODE>flex</CODE> scanners;=20
  <CODE>flex</CODE> ignores them.=20
  <LI>The name FLEX_SCANNER is #define'd so scanners may be written for =
use with=20
  either <CODE>flex</CODE> or <CODE>lex</CODE>. Scanners also include=20
  <CODE>YY_FLEX_MAJOR_VERSION</CODE> and =
<CODE>YY_FLEX_MINOR_VERSION</CODE>=20
  indicating which version of <CODE>flex</CODE> generated the scanner =
(for=20
  example, for the 2.5 release, these defines would be 2 and 5 =
respectively).=20
  </LI></UL>
<P>The following <CODE>flex</CODE> features are not included in =
<CODE>lex</CODE>=20
or the POSIX specification: <PRE>C++ scanners
%option
start condition scopes
start condition stacks
interactive/non-interactive scanners
yy_scan_string() and friends
yyterminate()
yy_set_interactive()
yy_set_bol()
YY_AT_BOL()
&lt;&lt;EOF&gt;&gt;
&lt;*&gt;
YY_DECL
YY_START
YY_USER_ACTION
YY_USER_INIT
#line directives
%{}'s around actions
multiple actions on a line
</PRE>
<P>plus almost all of the flex flags. The last feature in the list =
refers to the=20
fact that with <CODE>flex</CODE> you can put multiple actions on the =
same line,=20
separated with semicolons, while with <CODE>lex</CODE>, the following =
<PRE>foo    handle_foo(); ++num_foos_seen;
</PRE>
<P>is (rather surprisingly) truncated to <PRE>foo    handle_foo();
</PRE>
<P><CODE>flex</CODE> does not truncate the action. Actions that are not =
enclosed=20
in braces are simply terminated at the end of the line.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC21"=20
name=3DSEC21>Diagnostics</A></H2>
<DL compact>
  <DT><SAMP>`warning, rule cannot be matched'</SAMP>=20
  <DD>indicates that the given rule cannot be matched because it follows =
other=20
  rules that will always match the same text as it. For example, in the=20
  following "foo" cannot be matched because it comes after an identifier =

  "catch-all" rule: <PRE>[a-z]+    got_identifier();
foo       got_foo();
</PRE>Using <CODE>REJECT</CODE> in a scanner suppresses this warning.=20
  <DT><SAMP>`warning, -s option given but default rule can be =
matched'</SAMP>=20
  <DD>means that it is possible (perhaps only in a particular start =
condition)=20
  that the default rule (match any single character) is the only one =
that will=20
  match a particular input. Since <SAMP>`-s'</SAMP> was given, =
presumably this=20
  is not intended.=20
  <DT><SAMP>`reject_used_but_not_detected undefined'</SAMP>=20
  <DD>
  <DT><SAMP>`yymore_used_but_not_detected undefined'</SAMP>=20
  <DD>These errors can occur at compile time. They indicate that the =
scanner=20
  uses <CODE>REJECT</CODE> or <SAMP>`yymore()'</SAMP> but that =
<CODE>flex</CODE>=20
  failed to notice the fact, meaning that <CODE>flex</CODE> scanned the =
first=20
  two sections looking for occurrences of these actions and failed to =
find any,=20
  but somehow you snuck some in (via a #include file, for example). Use=20
  <SAMP>`%option reject'</SAMP> or <SAMP>`%option yymore'</SAMP> to =
indicate to=20
  flex that you really do use these features.=20
  <DT><SAMP>`flex scanner jammed'</SAMP>=20
  <DD>a scanner compiled with <SAMP>`-s'</SAMP> has encountered an input =
string=20
  which wasn't matched by any of its rules. This error can also occur =
due to=20
  internal problems.=20
  <DT><SAMP>`token too large, exceeds YYLMAX'</SAMP>=20
  <DD>your scanner uses <SAMP>`%array'</SAMP> and one of its rules =
matched a=20
  string longer than the <SAMP>`YYL-'</SAMP> <CODE>MAX</CODE> constant =
(8K bytes=20
  by default). You can increase the value by #define'ing =
<CODE>YYLMAX</CODE> in=20
  the definitions section of your <CODE>flex</CODE> input.=20
  <DT><SAMP>`scanner requires -8 flag to use the character=20
  '<VAR>x</VAR>''</SAMP>=20
  <DD>Your scanner specification includes recognizing the 8-bit =
character=20
  <VAR>x</VAR> and you did not specify the -8 flag, and your scanner =
defaulted=20
  to 7-bit because you used the <SAMP>`-Cf'</SAMP> or <SAMP>`-CF'</SAMP> =
table=20
  compression options. See the discussion of the <SAMP>`-7'</SAMP> flag =
for=20
  details.=20
  <DT><SAMP>`flex scanner push-back overflow'</SAMP>=20
  <DD>you used <SAMP>`unput()'</SAMP> to push back so much text that the =

  scanner's buffer could not hold both the pushed-back text and the =
current=20
  token in <CODE>yytext</CODE>. Ideally the scanner should dynamically =
resize=20
  the buffer in this case, but at present it does not.=20
  <DT><SAMP>`input buffer overflow, can't enlarge buffer because scanner =
uses=20
  REJECT'</SAMP>=20
  <DD>the scanner was working on matching an extremely large token and =
needed to=20
  expand the input buffer. This doesn't work with scanners that use=20
  <CODE>REJECT</CODE>.=20
  <DT><SAMP>`fatal flex scanner internal error--end of buffer =
missed'</SAMP>=20
  <DD>This can occur in an scanner which is reentered after a long-jump =
has=20
  jumped out (or over) the scanner's activation frame. Before reentering =
the=20
  scanner, use: <PRE>yyrestart( yyin );
</PRE>or, as noted above, switch to using the C++ scanner class.=20
  <DT><SAMP>`too many start conditions in &lt;&gt; construct!'</SAMP>=20
  <DD>you listed more start conditions in a &lt;&gt; construct than =
exist (so=20
  you must have listed at least one of them twice). </DD></DL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC22"=20
name=3DSEC22>Files</A></H2>
<DL compact>
  <DT><TT>`-lfl'</TT>=20
  <DD>library with which scanners must be linked.=20
  <DT><TT>`lex.yy.c'</TT>=20
  <DD>generated scanner (called <TT>`lexyy.c'</TT> on some systems).=20
  <DT><TT>`lex.yy.cc'</TT>=20
  <DD>generated C++ scanner class, when using <SAMP>`-+'</SAMP>.=20
  <DT><TT>`&lt;FlexLexer.h&gt;'</TT>=20
  <DD>header file defining the C++ scanner base class, =
<CODE>FlexLexer</CODE>,=20
  and its derived class, <CODE>yyFlexLexer</CODE>.=20
  <DT><TT>`flex.skl'</TT>=20
  <DD>skeleton scanner. This file is only used when building flex, not =
when flex=20
  executes.=20
  <DT><TT>`lex.backup'</TT>=20
  <DD>backing-up information for <SAMP>`-b'</SAMP> flag (called=20
  <TT>`lex.bck'</TT> on some systems). </DD></DL>
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC23"=20
name=3DSEC23>Deficiencies / Bugs</A></H2>
<P>Some trailing context patterns cannot be properly matched and =
generate=20
warning messages ("dangerous trailing context"). These are patterns =
where the=20
ending of the first part of the rule matches the beginning of the second =
part,=20
such as "zx*/xy*", where the 'x*' matches the 'x' at the beginning of =
the=20
trailing context. (Note that the POSIX draft states that the text =
matched by=20
such patterns is undefined.)=20
<P>For some trailing context rules, parts which are actually =
fixed-length are=20
not recognized as such, leading to the abovementioned performance loss. =
In=20
particular, parts using '|' or {n} (such as "foo{3}") are always =
considered=20
variable-length.=20
<P>Combining trailing context with the special '|' action can result in=20
<EM>fixed</EM> trailing context being turned into the more expensive=20
<VAR>variable</VAR> trailing context. For example, in the following: =
<PRE>%%
abc      |
xyz/def
</PRE>
<P>Use of <SAMP>`unput()'</SAMP> invalidates yytext and yyleng, unless =
the=20
<SAMP>`%array'</SAMP> directive or the <SAMP>`-l'</SAMP> option has been =
used.=20
<P>Pattern-matching of NUL's is substantially slower than matching other =

characters.=20
<P>Dynamic resizing of the input buffer is slow, as it entails =
rescanning all=20
the text matched so far by the current (generally huge) token.=20
<P>Due to both buffering of input and read-ahead, you cannot intermix =
calls to=20
&lt;stdio.h&gt; routines, such as, for example, =
<SAMP>`getchar()'</SAMP>, with=20
<CODE>flex</CODE> rules and expect it to work. Call =
<SAMP>`input()'</SAMP>=20
instead.=20
<P>The total table entries listed by the <SAMP>`-v'</SAMP> flag excludes =
the=20
number of table entries needed to determine what rule has been matched. =
The=20
number of entries is equal to the number of DFA states if the scanner =
does not=20
use <CODE>REJECT</CODE>, and somewhat greater than the number of states =
if it=20
does.=20
<P><CODE>REJECT</CODE> cannot be used with the <SAMP>`-f'</SAMP> or=20
<SAMP>`-F'</SAMP> options.=20
<P>The <CODE>flex</CODE> internal algorithms need documentation.=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC24"=20
name=3DSEC24>See also</A></H2>
<P><CODE>lex</CODE>(1), <CODE>yacc</CODE>(1), <CODE>sed</CODE>(1),=20
<CODE>awk</CODE>(1).=20
<P>John Levine, Tony Mason, and Doug Brown: Lex &amp; Yacc; O'Reilly and =

Associates. Be sure to get the 2nd edition.=20
<P>M. E. Lesk and E. Schmidt, LEX - Lexical Analyzer Generator.=20
<P>Alfred Aho, Ravi Sethi and Jeffrey Ullman: Compilers: Principles, =
Techniques=20
and Tools; Addison-Wesley (1986). Describes the pattern-matching =
techniques used=20
by <CODE>flex</CODE> (deterministic finite automata).=20
<H2><A =
href=3D"http://www.gnu.org/manual/flex-2.5.4/html_mono/flex.html#TOC25"=20
name=3DSEC25>Author</A></H2>
<P>Vern Paxson, with the help of many ideas and much inspiration from =
Van=20
Jacobson. Original version by Jef Poskanzer. The fast table =
representation is a=20
partial implementation of a design done by Van Jacobson. The =
implementation was=20
done by Kevin Gong and Vern Paxson.=20
<P>Thanks to the many <CODE>flex</CODE> beta-testers, feedbackers, and=20
contributors, especially Francois Pinard, Casey Leedom, Stan Adermann, =
Terry=20
Allen, David Barker-Plummer, John Basrai, Nelson H.F. Beebe,=20
<SAMP>`benson@odi.com'</SAMP>, Karl Berry, Peter A. Bigot, Simon =
Blanchard,=20
Keith Bostic, Frederic Brehm, Ian Brockbank, Kin Cho, Nick Christopher, =
Brian=20
Clapper, J.T. Conklin, Jason Coughlin, Bill Cox, Nick Cropper, Dave =
Curtis,=20
Scott David Daniels, Chris G. Demetriou, Theo Deraadt, Mike Donahue, =
Chuck=20
Doucette, Tom Epperly, Leo Eskin, Chris Faylor, Chris Flatters, Jon =
Forrest, Joe=20
Gayda, Kaveh R. Ghazi, Eric Goldman, Christopher M. Gould, Ulrich =
Grepel, Peer=20
Griebel, Jan Hajic, Charles Hemphill, NORO Hideo, Jarkko Hietaniemi, =
Scott=20
Hofmann, Jeff Honig, Dana Hudes, Eric Hughes, John Interrante, Ceriel =
Jacobs,=20
Michal Jaegermann, Sakari Jalovaara, Jeffrey R. Jones, Henry Juengst, =
Klaus=20
Kaempf, Jonathan I. Kamens, Terrence O Kane, Amir Katz,=20
<SAMP>`ken@ken.hilco.com'</SAMP>, Kevin B. Kenny, Steve Kirsch, Winfried =
Koenig,=20
Marq Kole, Ronald Lamprecht, Greg Lee, Rohan Lenard, Craig Leres, John =
Levine,=20
Steve Liddle, Mike Long, Mohamed el Lozy, Brian Madsen, Malte, Joe =
Marshall,=20
Bengt Martensson, Chris Metcalf, Luke Mewburn, Jim Meyering, R. =
Alexander=20
Milowski, Erik Naggum, G.T. Nicol, Landon Noll, James Nordby, Marc =
Nozell,=20
Richard Ohnemus, Karsten Pahnke, Sven Panne, Roland Pesch, Walter =
Pelissero,=20
Gaumond Pierre, Esmond Pitt, Jef Poskanzer, Joe Rahmeh, Jarmo Raiha, =
Frederic=20
Raimbault, Pat Rankin, Rick Richardson, Kevin Rodgers, Kai Uwe Rommel, =
Jim=20
Roskind, Alberto Santini, Andreas Scherer, Darrell Schiebel, Raf =
Schietekat,=20
Doug Schmidt, Philippe Schnoebelen, Andreas Schwab, Alex Siegel, =
Eckehard Stolz,=20
Jan-Erik Strvmquist, Mike Stump, Paul Stuart, Dave Tallman, Ian Lance =
Taylor,=20
Chris Thewalt, Richard M. Timoney, Jodi Tsai, Paul Tuinenga, Gary Weik, =
Frank=20
Whaley, Gerhard Wilhelms, Kent Williams, Ken Yap, Ron Zellar, Nathan =
Zelle,=20
David Zuhn, and those whose names have slipped my marginal =
mail-archiving skills=20
but whose contributions are appreciated all the same.=20
<P>Thanks to Keith Bostic, Jon Forrest, Noah Friedman, John Gilmore, =
Craig=20
Leres, John Levine, Bob Mulcahy, G.T. Nicol, Francois Pinard, Rich Salz, =
and=20
Richard Stallman for help with various distribution headaches.=20
<P>Thanks to Esmond Pitt and Earle Horton for 8-bit character support; =
to Benson=20
Margulies and Fred Burke for C++ support; to Kent Williams and Tom =
Epperly for=20
C++ class support; to Ove Ewerlid for support of NUL's; and to Eric =
Hughes for=20
support of multiple buffers.=20
<P>This work was primarily done when I was with the Real Time Systems =
Group at=20
the Lawrence Berkeley Laboratory in Berkeley, CA. Many thanks to all =
there for=20
the support I received.=20
<P>Send comments to <SAMP>`vern@ee.lbl.gov'</SAMP>.=20
<P>
<HR>

<P>This document was generated on 23 February 2001 using <A=20
href=3D"http://wwwinfo.cern.ch/dis/texi2html/">texi2html</A>&nbsp;1.56k. =

</P></BODY></HTML>
